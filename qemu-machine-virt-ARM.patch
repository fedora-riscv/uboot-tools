From patchwork Wed Aug 30 08:31:34 2017
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
Subject: [U-Boot,
 1/2] PCI: Add driver for a 'pci-host-ecam-generic' host controller
X-Patchwork-Submitter: Tuomas Tynkkynen <tuomas.tynkkynen@iki.fi>
X-Patchwork-Id: 807714
Message-Id: <20170830083135.9183-2-tuomas.tynkkynen@iki.fi>
To: u-boot@lists.denx.de
Cc: Tom Rini <trini@konsulko.com>
Date: Wed, 30 Aug 2017 11:31:34 +0300
From: Tuomas Tynkkynen <tuomas.tynkkynen@iki.fi>
List-Id: U-Boot discussion <u-boot.lists.denx.de>

QEMU emulates such a device with '-machine virt,highmem=off' on ARM.
The 'highmem=off' part is required for things to work as the PCI code
in U-Boot doesn't seem to support 64-bit BARs.

This driver is basically a copy-paste of the Xilinx PCIE driver with the
Xilinx-specific bits removed and compatible string changed... The
generic code should probably be extracted into some sort of library
functions instead of duplicating them before committing this driver.

Signed-off-by: Tuomas Tynkkynen <tuomas.tynkkynen@iki.fi>
---
 drivers/pci/Kconfig             |   8 ++
 drivers/pci/Makefile            |   1 +
 drivers/pci/pcie_ecam_generic.c | 193 ++++++++++++++++++++++++++++++++++++++++
 3 files changed, 202 insertions(+)
 create mode 100644 drivers/pci/pcie_ecam_generic.c

diff --git a/drivers/pci/Kconfig b/drivers/pci/Kconfig
index e2a1c0a409..745161fb9f 100644
--- a/drivers/pci/Kconfig
+++ b/drivers/pci/Kconfig
@@ -33,6 +33,14 @@ config PCI_PNP
 	help
 	  Enable PCI memory and I/O space resource allocation and assignment.
 
+config PCIE_ECAM_GENERIC
+	bool "Generic PCI-E ECAM support"
+	default n
+	depends on DM_PCI
+	help
+	  Say Y here if you want to enable support for generic ECAM-based
+	  PCIe controllers, such as the one emulated by QEMU.
+
 config PCIE_DW_MVEBU
 	bool "Enable Armada-8K PCIe driver (DesignWare core)"
 	default n
diff --git a/drivers/pci/Makefile b/drivers/pci/Makefile
index ad44e83996..5eb12efbf5 100644
--- a/drivers/pci/Makefile
+++ b/drivers/pci/Makefile
@@ -17,6 +17,7 @@ obj-$(CONFIG_PCI) += pci.o pci_auto_old.o
 endif
 obj-$(CONFIG_PCI) += pci_auto_common.o pci_common.o
 
+obj-$(CONFIG_PCIE_ECAM_GENERIC) += pcie_ecam_generic.o
 obj-$(CONFIG_FSL_PCI_INIT) += fsl_pci_init.o
 obj-$(CONFIG_PCI_INDIRECT_BRIDGE) += pci_indirect.o
 obj-$(CONFIG_PCI_GT64120) += pci_gt64120.o
diff --git a/drivers/pci/pcie_ecam_generic.c b/drivers/pci/pcie_ecam_generic.c
new file mode 100644
index 0000000000..039e378cb0
--- /dev/null
+++ b/drivers/pci/pcie_ecam_generic.c
@@ -0,0 +1,193 @@
+/*
+ * Generic PCIE host provided by e.g. QEMU
+ *
+ * Heavily based on drivers/pci/pcie_xilinx.c
+ *
+ * Copyright (C) 2016 Imagination Technologies
+ *
+ * SPDX-License-Identifier:	GPL-2.0
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <pci.h>
+
+#include <asm/io.h>
+
+/**
+ * struct generic_ecam_pcie - generic_ecam PCIe controller state
+ * @hose: The parent classes PCI controller state
+ * @cfg_base: The base address of memory mapped configuration space
+ */
+struct generic_ecam_pcie {
+	struct pci_controller hose;
+	void *cfg_base;
+};
+
+/**
+ * pcie_generic_ecam_config_address() - Calculate the address of a config access
+ * @pcie: Pointer to the PCI controller state
+ * @bdf: Identifies the PCIe device to access
+ * @offset: The offset into the device's configuration space
+ * @paddress: Pointer to the pointer to write the calculates address to
+ *
+ * Calculates the address that should be accessed to perform a PCIe
+ * configuration space access for a given device identified by the PCIe
+ * controller device @pcie and the bus, device & function numbers in @bdf. If
+ * access to the device is not valid then the function will return an error
+ * code. Otherwise the address to access will be written to the pointer pointed
+ * to by @paddress.
+ *
+ * Return: 0 on success, else -ENODEV
+ */
+static int pcie_generic_ecam_config_address(struct generic_ecam_pcie *pcie, pci_dev_t bdf,
+				      uint offset, void **paddress)
+{
+	unsigned int bus = PCI_BUS(bdf);
+	unsigned int dev = PCI_DEV(bdf);
+	unsigned int func = PCI_FUNC(bdf);
+	void *addr;
+
+	addr = pcie->cfg_base;
+	addr += bus << 20;
+	addr += dev << 15;
+	addr += func << 12;
+	addr += offset;
+	*paddress = addr;
+
+	return 0;
+}
+
+/**
+ * pcie_generic_ecam_read_config() - Read from configuration space
+ * @pcie: Pointer to the PCI controller state
+ * @bdf: Identifies the PCIe device to access
+ * @offset: The offset into the device's configuration space
+ * @valuep: A pointer at which to store the read value
+ * @size: Indicates the size of access to perform
+ *
+ * Read a value of size @size from offset @offset within the configuration
+ * space of the device identified by the bus, device & function numbers in @bdf
+ * on the PCI bus @bus.
+ *
+ * Return: 0 on success, else -ENODEV or -EINVAL
+ */
+static int pcie_generic_ecam_read_config(struct udevice *bus, pci_dev_t bdf,
+				   uint offset, ulong *valuep,
+				   enum pci_size_t size)
+{
+	struct generic_ecam_pcie *pcie = dev_get_priv(bus);
+	void *address;
+	int err;
+
+	err = pcie_generic_ecam_config_address(pcie, bdf, offset, &address);
+	if (err < 0) {
+		*valuep = pci_get_ff(size);
+		return 0;
+	}
+
+	switch (size) {
+	case PCI_SIZE_8:
+		*valuep = __raw_readb(address);
+		return 0;
+	case PCI_SIZE_16:
+		*valuep = __raw_readw(address);
+		return 0;
+	case PCI_SIZE_32:
+		*valuep = __raw_readl(address);
+		return 0;
+	default:
+		return -EINVAL;
+	}
+}
+
+/**
+ * pcie_generic_ecam_write_config() - Write to configuration space
+ * @pcie: Pointer to the PCI controller state
+ * @bdf: Identifies the PCIe device to access
+ * @offset: The offset into the device's configuration space
+ * @value: The value to write
+ * @size: Indicates the size of access to perform
+ *
+ * Write the value @value of size @size from offset @offset within the
+ * configuration space of the device identified by the bus, device & function
+ * numbers in @bdf on the PCI bus @bus.
+ *
+ * Return: 0 on success, else -ENODEV or -EINVAL
+ */
+static int pcie_generic_ecam_write_config(struct udevice *bus, pci_dev_t bdf,
+				    uint offset, ulong value,
+				    enum pci_size_t size)
+{
+	struct generic_ecam_pcie *pcie = dev_get_priv(bus);
+	void *address;
+	int err;
+
+	err = pcie_generic_ecam_config_address(pcie, bdf, offset, &address);
+	if (err < 0)
+		return 0;
+
+	switch (size) {
+	case PCI_SIZE_8:
+		__raw_writeb(value, address);
+		return 0;
+	case PCI_SIZE_16:
+		__raw_writew(value, address);
+		return 0;
+	case PCI_SIZE_32:
+		__raw_writel(value, address);
+		return 0;
+	default:
+		return -EINVAL;
+	}
+}
+
+/**
+ * pcie_generic_ecam_ofdata_to_platdata() - Translate from DT to device state
+ * @dev: A pointer to the device being operated on
+ *
+ * Translate relevant data from the device tree pertaining to device @dev into
+ * state that the driver will later make use of. This state is stored in the
+ * device's private data structure.
+ *
+ * Return: 0 on success, else -EINVAL
+ */
+static int pcie_generic_ecam_ofdata_to_platdata(struct udevice *dev)
+{
+	struct generic_ecam_pcie *pcie = dev_get_priv(dev);
+	struct fdt_resource reg_res;
+	DECLARE_GLOBAL_DATA_PTR;
+	int err;
+
+	err = fdt_get_resource(gd->fdt_blob, dev_of_offset(dev), "reg",
+			       0, &reg_res);
+	if (err < 0) {
+		error("\"reg\" resource not found\n");
+		return err;
+	}
+
+	pcie->cfg_base = map_physmem(reg_res.start,
+				     fdt_resource_size(&reg_res),
+				     MAP_NOCACHE);
+
+	return 0;
+}
+
+static const struct dm_pci_ops pcie_generic_ecam_ops = {
+	.read_config	= pcie_generic_ecam_read_config,
+	.write_config	= pcie_generic_ecam_write_config,
+};
+
+static const struct udevice_id pcie_generic_ecam_ids[] = {
+	{ .compatible = "pci-host-ecam-generic" },
+	{ }
+};
+
+U_BOOT_DRIVER(pcie_generic_ecam) = {
+	.name			= "pcie_generic_ecam",
+	.id			= UCLASS_PCI,
+	.of_match		= pcie_generic_ecam_ids,
+	.ops			= &pcie_generic_ecam_ops,
+	.ofdata_to_platdata	= pcie_generic_ecam_ofdata_to_platdata,
+	.priv_auto_alloc_size	= sizeof(struct generic_ecam_pcie),
+};

From patchwork Wed Aug 30 08:31:35 2017
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
Subject: [U-Boot,2/2] ARM: Add a new arch + board for QEMU's 'virt' machine
X-Patchwork-Submitter: Tuomas Tynkkynen <tuomas.tynkkynen@iki.fi>
X-Patchwork-Id: 807716
Message-Id: <20170830083135.9183-3-tuomas.tynkkynen@iki.fi>
To: u-boot@lists.denx.de
Cc: Tom Rini <trini@konsulko.com>
Date: Wed, 30 Aug 2017 11:31:35 +0300
From: Tuomas Tynkkynen <tuomas.tynkkynen@iki.fi>
List-Id: U-Boot discussion <u-boot.lists.denx.de>

This board builds an U-Boot binary that is bootable with QEMU's 'virt'
machine on ARM. The minimal QEMU command line is:

    qemu-system-arm -machine virt,highmem=off -bios u-boot.bin

(Note that the 'highmem=off' parameter to the 'virt' machine is required for
PCI to work in U-Boot.) This command line enables the following:
    - u-boot.bin loaded and executing in the emulated flash at address 0x0
    - A generated device tree blob placed at the start of RAM
    - A freely configurable amount of RAM, described by the DTB
    - A PL011 serial port, discoverable via the DTB
    - An ARMv7 architected timer
    - PSCI for rebooting the system
    - A generic ECAM-based PCI host controller, discoverable via the DTB

Additionally, QEMU allows plugging a bunch of useful peripherals to the PCI bus.
The following ones are supported by both U-Boot and Linux:

- To enable a Serial ATA disk via an Intel ICH9 AHCI controller, pass e.g.:
    -drive if=none,file=disk.img,id=mydisk -device ich9-ahci,id=ahci -device ide-drive,drive=mydisk,bus=ahci.0
- To enable an Intel E1000 network adapter, pass e.g.:
    -net nic,model=e1000 -net user
- To add an EHCI-compliant USB host controller, pass e.g.:
    -device usb-ehci,id=ehci

Signed-off-by: Tuomas Tynkkynen <tuomas.tynkkynen@iki.fi>
---
 arch/arm/Kconfig           | 10 ++++++++
 arch/arm/mach-qemu/Kconfig |  9 +++++++
 board/qemu-arm/Makefile    |  5 ++++
 board/qemu-arm/qemu-arm.c  | 35 ++++++++++++++++++++++++++
 configs/qemu_arm_defconfig | 27 ++++++++++++++++++++
 include/configs/qemu-arm.h | 63 ++++++++++++++++++++++++++++++++++++++++++++++
 6 files changed, 149 insertions(+)
 create mode 100644 arch/arm/mach-qemu/Kconfig
 create mode 100644 board/qemu-arm/Makefile
 create mode 100644 board/qemu-arm/qemu-arm.c
 create mode 100644 configs/qemu_arm_defconfig
 create mode 100644 include/configs/qemu-arm.h

diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 53d0831935..0d01ba1b73 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -630,6 +630,14 @@ config ARCH_MX5
 	select CPU_V7
 	select BOARD_EARLY_INIT_F
 
+config ARCH_QEMU
+	bool "QEMU Virtual Platform"
+	select CPU_V7
+	select ARCH_SUPPORT_PSCI
+	select DM
+	select DM_SERIAL
+	select OF_CONTROL
+
 config ARCH_RMOBILE
 	bool "Renesas ARM SoCs"
 	select DM
@@ -1149,6 +1157,8 @@ source "arch/arm/mach-stm32/Kconfig"
 
 source "arch/arm/mach-sunxi/Kconfig"
 
+source "arch/arm/mach-qemu/Kconfig"
+
 source "arch/arm/mach-tegra/Kconfig"
 
 source "arch/arm/mach-uniphier/Kconfig"
diff --git a/arch/arm/mach-qemu/Kconfig b/arch/arm/mach-qemu/Kconfig
new file mode 100644
index 0000000000..89d2a36719
--- /dev/null
+++ b/arch/arm/mach-qemu/Kconfig
@@ -0,0 +1,9 @@
+if ARCH_QEMU
+
+config SYS_BOARD
+	default "qemu-arm"
+
+config SYS_CONFIG_NAME
+	default "qemu-arm"
+
+endif
diff --git a/board/qemu-arm/Makefile b/board/qemu-arm/Makefile
new file mode 100644
index 0000000000..3e9907d983
--- /dev/null
+++ b/board/qemu-arm/Makefile
@@ -0,0 +1,5 @@
+#
+# SPDX-License-Identifier:	GPL-2.0
+#
+
+obj-y	+= qemu-arm.o
diff --git a/board/qemu-arm/qemu-arm.c b/board/qemu-arm/qemu-arm.c
new file mode 100644
index 0000000000..90d7badbf4
--- /dev/null
+++ b/board/qemu-arm/qemu-arm.c
@@ -0,0 +1,35 @@
+/*
+ * Copyright (c) 2017 Tuomas Tynkkynen
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#include <common.h>
+#include <fdtdec.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+int board_init(void)
+{
+	return 0;
+}
+
+int dram_init(void)
+{
+	if (fdtdec_setup_memory_size() != 0)
+		return -EINVAL;
+
+	return 0;
+}
+
+int dram_init_banksize(void)
+{
+	fdtdec_setup_memory_banksize();
+
+	return 0;
+}
+
+void *board_fdt_blob_setup(void)
+{
+	/* QEMU loads a generated DTB for us at the start of RAM. */
+	return (void *)CONFIG_SYS_SDRAM_BASE;
+}
diff --git a/configs/qemu_arm_defconfig b/configs/qemu_arm_defconfig
new file mode 100644
index 0000000000..d34512dd0d
--- /dev/null
+++ b/configs/qemu_arm_defconfig
@@ -0,0 +1,27 @@
+CONFIG_ARM=y
+CONFIG_ARM_SMCCC=y
+CONFIG_ARCH_QEMU=y
+CONFIG_AHCI=y
+CONFIG_DISTRO_DEFAULTS=y
+# CONFIG_DISPLAY_CPUINFO is not set
+# CONFIG_DISPLAY_BOARDINFO is not set
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_PCI=y
+CONFIG_CMD_USB=y
+CONFIG_OF_BOARD=y
+CONFIG_AHCI_PCI=y
+CONFIG_BLK=y
+# CONFIG_MMC is not set
+CONFIG_DM_ETH=y
+CONFIG_E1000=y
+CONFIG_PCI=y
+CONFIG_DM_PCI=y
+CONFIG_PCIE_ECAM_GENERIC=y
+CONFIG_SCSI=y
+CONFIG_DM_SCSI=y
+CONFIG_SYSRESET=y
+CONFIG_SYSRESET_PSCI=y
+CONFIG_USB=y
+CONFIG_DM_USB=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_PCI=y
diff --git a/include/configs/qemu-arm.h b/include/configs/qemu-arm.h
new file mode 100644
index 0000000000..2bcc0efad0
--- /dev/null
+++ b/include/configs/qemu-arm.h
@@ -0,0 +1,63 @@
+/*
+ * Copyright (c) 2017 Tuomas Tynkkynen
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <linux/sizes.h>
+
+/* Physical memory map */
+#define CONFIG_SYS_TEXT_BASE		0x00000000
+
+#define CONFIG_NR_DRAM_BANKS		1
+#define CONFIG_SYS_SDRAM_BASE		0x40000000
+
+/* The DTB generated by QEMU is placed at start of RAM, stay away from there */
+#define CONFIG_SYS_INIT_SP_ADDR         (CONFIG_SYS_SDRAM_BASE + SZ_2M)
+#define CONFIG_SYS_LOAD_ADDR		(CONFIG_SYS_SDRAM_BASE + SZ_2M)
+#define CONFIG_SYS_MALLOC_LEN		SZ_16M
+
+/* QEMU's PL011 serial port is detected via FDT using the device model */
+#define CONFIG_PL01X_SERIAL
+
+/* QEMU implements a 62.5MHz architected timer */
+/* FIXME: can we rely on CNTFREQ instead of hardcoding this fact here? */
+#define CONFIG_SYS_ARCH_TIMER
+#define CONFIG_SYS_HZ                       1000
+#define CONFIG_SYS_HZ_CLOCK                 62500000
+
+/* Command prompt options */
+#define CONFIG_SYS_CBSIZE		512	/* Console I/O Buffer Size */
+#define CONFIG_SYS_PBSIZE		(CONFIG_SYS_CBSIZE + \
+					sizeof(CONFIG_SYS_PROMPT) + 16)
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE
+#define CONFIG_SYS_MAXARGS		64	/* max command args */
+
+/* For block devices, QEMU emulates an ICH9 AHCI controller over PCI */
+#define CONFIG_SYS_SCSI_MAX_SCSI_ID 8
+#define CONFIG_SCSI_AHCI
+#define CONFIG_LIBATA
+
+/* Environment options */
+#define CONFIG_ENV_SIZE				SZ_64K
+
+#include <config_distro_defaults.h>
+
+#define BOOT_TARGET_DEVICES(func) \
+	func(SCSI, scsi, 0)
+
+#include <config_distro_bootcmd.h>
+
+#define CONFIG_PREBOOT "pci enum"
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	"fdt_addr=0x40000000\0" \
+	"scriptaddr=0x40200000\0" \
+	"pxefile_addr_r=0x40300000\0" \
+	"kernel_addr_r=0x40400000\0" \
+	"ramdisk_addr_r=0x44000000\0" \
+	BOOTENV
+
+#endif /* __CONFIG_H */
