From patchwork Tue Apr 16 16:24:16 2019
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
Subject: [U-Boot, v2,
 1/2] net: eth-uclass: Write MAC address to hardware after probe
X-Patchwork-Submitter: Thierry Reding <thierry.reding@gmail.com>
X-Patchwork-Id: 1086417
Message-Id: <20190416162417.25799-1-thierry.reding@gmail.com>
To: Simon Glass <sjg@chromium.org>, Joe Hershberger <joe.hershberger@ni.com>
Cc: u-boot@lists.denx.de
Date: Tue, 16 Apr 2019 18:24:16 +0200
From: Thierry Reding <thierry.reding@gmail.com>
List-Id: U-Boot discussion <u-boot.lists.denx.de>

From: Thierry Reding <treding@nvidia.com>

In order for the device to use the proper MAC address, which can have
been configured in the environment prior to the device being registered,
ensure that the MAC address is written after the device has been probed.
For devices that are registered before the network stack is initialized,
this is already done during eth_initialize(). If the Ethernet device is
on a bus that is not initialized on early boot, such as PCI, the device
is not available at the time eth_initialize() is called, so we need the
MAC address programming to also happen after probe.

Signed-off-by: Thierry Reding <treding@nvidia.com>
---
 net/eth-uclass.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/net/eth-uclass.c b/net/eth-uclass.c
index 2ef20df19203..4225aabf1fa1 100644
--- a/net/eth-uclass.c
+++ b/net/eth-uclass.c
@@ -524,6 +524,8 @@ static int eth_post_probe(struct udevice *dev)
 #endif
 	}
 
+	eth_write_hwaddr(dev);
+
 	return 0;
 }
 

From patchwork Tue Apr 16 16:24:17 2019
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
Subject: [U-Boot,v2,2/2] net: eth-uclass: Support device tree MAC addresses
X-Patchwork-Submitter: Thierry Reding <thierry.reding@gmail.com>
X-Patchwork-Id: 1086418
Message-Id: <20190416162417.25799-2-thierry.reding@gmail.com>
To: Simon Glass <sjg@chromium.org>, Joe Hershberger <joe.hershberger@ni.com>
Cc: u-boot@lists.denx.de
Date: Tue, 16 Apr 2019 18:24:17 +0200
From: Thierry Reding <thierry.reding@gmail.com>
List-Id: U-Boot discussion <u-boot.lists.denx.de>

From: Thierry Reding <treding@nvidia.com>

Add the standard Ethernet device tree bindings (imported from v5.0 of
the Linux kernel) and implement support for reading the MAC address for
Ethernet devices in the Ethernet uclass. If the "mac-address" property
exists, the MAC address will be parsed from that. If that property does
not exist, the "local-mac-address" property will be tried as fallback.

MAC addresses from device tree take precedence over the ones stored in
a network interface card's ROM.

Acked-by: Joe Hershberger <joe.hershberger@ni.com>
Signed-off-by: Thierry Reding <treding@nvidia.com>
---
Changes in v2:
- use dev_read_u8_array_ptr()

 .../devicetree/bindings/net/ethernet.txt      | 66 +++++++++++++++++++
 net/eth-uclass.c                              | 26 +++++++-
 2 files changed, 89 insertions(+), 3 deletions(-)
 create mode 100644 Documentation/devicetree/bindings/net/ethernet.txt

diff --git a/Documentation/devicetree/bindings/net/ethernet.txt b/Documentation/devicetree/bindings/net/ethernet.txt
new file mode 100644
index 000000000000..cfc376bc977a
--- /dev/null
+++ b/Documentation/devicetree/bindings/net/ethernet.txt
@@ -0,0 +1,66 @@
+The following properties are common to the Ethernet controllers:
+
+NOTE: All 'phy*' properties documented below are Ethernet specific. For the
+generic PHY 'phys' property, see
+Documentation/devicetree/bindings/phy/phy-bindings.txt.
+
+- local-mac-address: array of 6 bytes, specifies the MAC address that was
+  assigned to the network device;
+- mac-address: array of 6 bytes, specifies the MAC address that was last used by
+  the boot program; should be used in cases where the MAC address assigned to
+  the device by the boot program is different from the "local-mac-address"
+  property;
+- nvmem-cells: phandle, reference to an nvmem node for the MAC address;
+- nvmem-cell-names: string, should be "mac-address" if nvmem is to be used;
+- max-speed: number, specifies maximum speed in Mbit/s supported by the device;
+- max-frame-size: number, maximum transfer unit (IEEE defined MTU), rather than
+  the maximum frame size (there's contradiction in the Devicetree
+  Specification).
+- phy-mode: string, operation mode of the PHY interface. This is now a de-facto
+  standard property; supported values are:
+  * "internal"
+  * "mii"
+  * "gmii"
+  * "sgmii"
+  * "qsgmii"
+  * "tbi"
+  * "rev-mii"
+  * "rmii"
+  * "rgmii" (RX and TX delays are added by the MAC when required)
+  * "rgmii-id" (RGMII with internal RX and TX delays provided by the PHY, the
+     MAC should not add the RX or TX delays in this case)
+  * "rgmii-rxid" (RGMII with internal RX delay provided by the PHY, the MAC
+     should not add an RX delay in this case)
+  * "rgmii-txid" (RGMII with internal TX delay provided by the PHY, the MAC
+     should not add an TX delay in this case)
+  * "rtbi"
+  * "smii"
+  * "xgmii"
+  * "trgmii"
+  * "2000base-x",
+  * "2500base-x",
+  * "rxaui"
+  * "xaui"
+  * "10gbase-kr" (10GBASE-KR, XFI, SFI)
+- phy-connection-type: the same as "phy-mode" property but described in the
+  Devicetree Specification;
+- phy-handle: phandle, specifies a reference to a node representing a PHY
+  device; this property is described in the Devicetree Specification and so
+  preferred;
+- phy: the same as "phy-handle" property, not recommended for new bindings.
+- phy-device: the same as "phy-handle" property, not recommended for new
+  bindings.
+- rx-fifo-depth: the size of the controller's receive fifo in bytes. This
+  is used for components that can have configurable receive fifo sizes,
+  and is useful for determining certain configuration settings such as
+  flow control thresholds.
+- tx-fifo-depth: the size of the controller's transmit fifo in bytes. This
+  is used for components that can have configurable fifo sizes.
+- managed: string, specifies the PHY management type. Supported values are:
+  "auto", "in-band-status". "auto" is the default, it usess MDIO for
+  management if fixed-link is not specified.
+
+Child nodes of the Ethernet controller are typically the individual PHY devices
+connected via the MDIO bus (sometimes the MDIO bus controller is separate).
+They are described in the phy.txt file in this same directory.
+For non-MDIO PHY management see fixed-link.txt.
diff --git a/net/eth-uclass.c b/net/eth-uclass.c
index 4225aabf1fa1..c6d5ec013bd8 100644
--- a/net/eth-uclass.c
+++ b/net/eth-uclass.c
@@ -455,6 +455,23 @@ static int eth_pre_unbind(struct udevice *dev)
 	return 0;
 }
 
+static bool eth_dev_get_mac_address(struct udevice *dev, u8 mac[ARP_HLEN])
+{
+	const uint8_t *p;
+
+	p = dev_read_u8_array_ptr(dev, "mac-address", ARP_HLEN);
+	if (!p)
+		p = dev_read_u8_array_ptr(dev, "local-mac-address", ARP_HLEN);
+
+	if (!p) {
+		memset(mac, 0, ARP_HLEN);
+		return false;
+	}
+
+	memcpy(mac, p, ARP_HLEN);
+	return true;
+}
+
 static int eth_post_probe(struct udevice *dev)
 {
 	struct eth_device_priv *priv = dev->uclass_priv;
@@ -489,9 +506,12 @@ static int eth_post_probe(struct udevice *dev)
 
 	priv->state = ETH_STATE_INIT;
 
-	/* Check if the device has a MAC address in ROM */
-	if (eth_get_ops(dev)->read_rom_hwaddr)
-		eth_get_ops(dev)->read_rom_hwaddr(dev);
+	/* Check if the device has a MAC address in device tree */
+	if (!eth_dev_get_mac_address(dev, pdata->enetaddr)) {
+		/* Check if the device has a MAC address in ROM */
+		if (eth_get_ops(dev)->read_rom_hwaddr)
+			eth_get_ops(dev)->read_rom_hwaddr(dev);
+	}
 
 	eth_env_get_enetaddr_by_index("eth", dev->seq, env_enetaddr);
 	if (!is_zero_ethaddr(env_enetaddr)) {
