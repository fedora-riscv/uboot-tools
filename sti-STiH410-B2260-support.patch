From d47e40830ae8406e248880b7eb08bead00377adc Mon Sep 17 00:00:00 2001
From: Patrice Chotard <patrice.chotard@st.com>
Date: Mon, 13 Feb 2017 10:24:16 +0100
Subject: [PATCH 01/16] mmc: sti_sdhci: Rework sti_mmc_core_config()

Use struct udevice* as input parameter. Previous
parameters are retrieved through plat and priv data.

This to prepare to use the reset framework.

Signed-off-by: Patrice Chotard <patrice.chotard@st.com>
Reviewed-by: Jaehoon Chung <jh80.chung@samsung.com>
---
 drivers/mmc/sti_sdhci.c | 33 ++++++++++++++++++---------------
 1 file changed, 18 insertions(+), 15 deletions(-)

diff --git a/drivers/mmc/sti_sdhci.c b/drivers/mmc/sti_sdhci.c
index 2a07082036..d6c4d677b8 100644
--- a/drivers/mmc/sti_sdhci.c
+++ b/drivers/mmc/sti_sdhci.c
@@ -16,6 +16,7 @@ DECLARE_GLOBAL_DATA_PTR;
 struct sti_sdhci_plat {
 	struct mmc_config cfg;
 	struct mmc mmc;
+	int instance;
 };
 
 /*
@@ -26,8 +27,8 @@ struct sti_sdhci_plat {
 
 /**
  * sti_mmc_core_config: configure the Arasan HC
- * @regbase: base address
- * @mmc_instance: mmc instance id
+ * @dev : udevice
+ *
  * Description: this function is to configure the Arasan MMC HC.
  * This should be called when the system starts in case of, on the SoC,
  * it is needed to configure the host controller.
@@ -36,33 +37,35 @@ struct sti_sdhci_plat {
  * W/o these settings the SDHCI could configure and use the embedded controller
  * with limited features.
  */
-static void sti_mmc_core_config(const u32 regbase, int mmc_instance)
+static void sti_mmc_core_config(struct udevice *dev)
 {
+	struct sti_sdhci_plat *plat = dev_get_platdata(dev);
+	struct sdhci_host *host = dev_get_priv(dev);
 	unsigned long *sysconf;
 
 	/* only MMC1 has a reset line */
-	if (mmc_instance) {
+	if (plat->instance) {
 		sysconf = (unsigned long *)(STIH410_SYSCONF5_BASE +
 			  ST_MMC_CCONFIG_REG_5);
 		generic_set_bit(SYSCONF_MMC1_ENABLE_BIT, sysconf);
 	}
 
 	writel(STI_FLASHSS_MMC_CORE_CONFIG_1,
-	       regbase + FLASHSS_MMC_CORE_CONFIG_1);
+	       host->ioaddr + FLASHSS_MMC_CORE_CONFIG_1);
 
-	if (mmc_instance) {
+	if (plat->instance) {
 		writel(STI_FLASHSS_MMC_CORE_CONFIG2,
-		       regbase + FLASHSS_MMC_CORE_CONFIG_2);
+		       host->ioaddr + FLASHSS_MMC_CORE_CONFIG_2);
 		writel(STI_FLASHSS_MMC_CORE_CONFIG3,
-		       regbase + FLASHSS_MMC_CORE_CONFIG_3);
+		       host->ioaddr + FLASHSS_MMC_CORE_CONFIG_3);
 	} else {
 		writel(STI_FLASHSS_SDCARD_CORE_CONFIG2,
-		       regbase + FLASHSS_MMC_CORE_CONFIG_2);
+		       host->ioaddr + FLASHSS_MMC_CORE_CONFIG_2);
 		writel(STI_FLASHSS_SDCARD_CORE_CONFIG3,
-		       regbase + FLASHSS_MMC_CORE_CONFIG_3);
+		       host->ioaddr + FLASHSS_MMC_CORE_CONFIG_3);
 	}
 	writel(STI_FLASHSS_MMC_CORE_CONFIG4,
-	       regbase + FLASHSS_MMC_CORE_CONFIG_4);
+	       host->ioaddr + FLASHSS_MMC_CORE_CONFIG_4);
 }
 
 static int sti_sdhci_probe(struct udevice *dev)
@@ -70,7 +73,7 @@ static int sti_sdhci_probe(struct udevice *dev)
 	struct mmc_uclass_priv *upriv = dev_get_uclass_priv(dev);
 	struct sti_sdhci_plat *plat = dev_get_platdata(dev);
 	struct sdhci_host *host = dev_get_priv(dev);
-	int ret, mmc_instance;
+	int ret;
 
 	/*
 	 * identify current mmc instance, mmc1 has a reset, not mmc0
@@ -79,11 +82,11 @@ static int sti_sdhci_probe(struct udevice *dev)
 	 */
 
 	if (fdt_getprop(gd->fdt_blob, dev_of_offset(dev), "resets", NULL))
-		mmc_instance = 1;
+		plat->instance = 1;
 	else
-		mmc_instance = 0;
+		plat->instance = 0;
 
-	sti_mmc_core_config((const u32) host->ioaddr, mmc_instance);
+	sti_mmc_core_config(dev);
 
 	host->quirks = SDHCI_QUIRK_WAIT_SEND_CMD |
 		       SDHCI_QUIRK_32BIT_DMA_ADDR |
-- 
2.12.2

From 7a13a40753f67f4989d08e11ce67059206c95e2c Mon Sep 17 00:00:00 2001
From: Patrice Chotard <patrice.chotard@st.com>
Date: Mon, 13 Feb 2017 10:00:07 +0100
Subject: [PATCH 02/16] ARM: dts: stih410-family: Add missing reset_names for
 mmc1 node

reset-names property is needed to use the reset
API for STi sdhci driver.

Signed-off-by: Patrice Chotard <patrice.chotard@st.com>
Reviewed-by: Jaehoon Chung <jh80.chung@samsung.com>
---
 arch/arm/dts/stih407-family.dtsi | 1 +
 1 file changed, 1 insertion(+)

diff --git a/arch/arm/dts/stih407-family.dtsi b/arch/arm/dts/stih407-family.dtsi
index af66b53471..452ac1cdce 100644
--- a/arch/arm/dts/stih407-family.dtsi
+++ b/arch/arm/dts/stih407-family.dtsi
@@ -563,6 +563,7 @@
 			clocks = <&clk_s_c0_flexgen CLK_MMC_1>,
 				 <&clk_s_c0_flexgen CLK_RX_ICN_HVA>;
 			resets = <&softreset STIH407_MMC1_SOFTRESET>;
+			reset-names = "softreset";
 			bus-width = <4>;
 		};
 
-- 
2.12.2

From ef5fc6a1069e21332358d2b3b2fb4ee926cb4e11 Mon Sep 17 00:00:00 2001
From: Patrice Chotard <patrice.chotard@st.com>
Date: Tue, 28 Feb 2017 18:18:42 +0100
Subject: [PATCH 03/16] mmc: sti_sdhci: Use reset framework

Signed-off-by: Patrice Chotard <patrice.chotard@st.com>
Reviewed-by: Jaehoon Chung <jh80.chung@samsung.com>
---
 drivers/mmc/sti_sdhci.c | 31 ++++++++++++++++++++++---------
 1 file changed, 22 insertions(+), 9 deletions(-)

diff --git a/drivers/mmc/sti_sdhci.c b/drivers/mmc/sti_sdhci.c
index d6c4d677b8..8b1b2c08a1 100644
--- a/drivers/mmc/sti_sdhci.c
+++ b/drivers/mmc/sti_sdhci.c
@@ -8,6 +8,7 @@
 #include <common.h>
 #include <dm.h>
 #include <mmc.h>
+#include <reset-uclass.h>
 #include <sdhci.h>
 #include <asm/arch/sdhci.h>
 
@@ -16,6 +17,7 @@ DECLARE_GLOBAL_DATA_PTR;
 struct sti_sdhci_plat {
 	struct mmc_config cfg;
 	struct mmc mmc;
+	struct reset_ctl reset;
 	int instance;
 };
 
@@ -37,17 +39,19 @@ struct sti_sdhci_plat {
  * W/o these settings the SDHCI could configure and use the embedded controller
  * with limited features.
  */
-static void sti_mmc_core_config(struct udevice *dev)
+static int sti_mmc_core_config(struct udevice *dev)
 {
 	struct sti_sdhci_plat *plat = dev_get_platdata(dev);
 	struct sdhci_host *host = dev_get_priv(dev);
-	unsigned long *sysconf;
+	int ret;
 
 	/* only MMC1 has a reset line */
 	if (plat->instance) {
-		sysconf = (unsigned long *)(STIH410_SYSCONF5_BASE +
-			  ST_MMC_CCONFIG_REG_5);
-		generic_set_bit(SYSCONF_MMC1_ENABLE_BIT, sysconf);
+		ret = reset_deassert(&plat->reset);
+		if (ret < 0) {
+			error("MMC1 deassert failed: %d", ret);
+			return ret;
+		}
 	}
 
 	writel(STI_FLASHSS_MMC_CORE_CONFIG_1,
@@ -66,6 +70,8 @@ static void sti_mmc_core_config(struct udevice *dev)
 	}
 	writel(STI_FLASHSS_MMC_CORE_CONFIG4,
 	       host->ioaddr + FLASHSS_MMC_CORE_CONFIG_4);
+
+	return 0;
 }
 
 static int sti_sdhci_probe(struct udevice *dev)
@@ -80,13 +86,20 @@ static int sti_sdhci_probe(struct udevice *dev)
 	 * MMC0 is wired to the SD slot,
 	 * MMC1 is wired on the high speed connector
 	 */
-
-	if (fdt_getprop(gd->fdt_blob, dev_of_offset(dev), "resets", NULL))
+	if (fdt_getprop(gd->fdt_blob, dev_of_offset(dev), "resets", NULL)) {
 		plat->instance = 1;
-	else
+		ret = reset_get_by_name(dev, "softreset", &plat->reset);
+		if (ret) {
+			error("can't get reset for %s (%d)", dev->name, ret);
+			return ret;
+		}
+	} else {
 		plat->instance = 0;
+	}
 
-	sti_mmc_core_config(dev);
+	ret = sti_mmc_core_config(dev);
+	if (ret)
+		return ret;
 
 	host->quirks = SDHCI_QUIRK_WAIT_SEND_CMD |
 		       SDHCI_QUIRK_32BIT_DMA_ADDR |
-- 
2.12.2

From 2692e55b3ed1579c33bd288d5ecddd562349d248 Mon Sep 17 00:00:00 2001
From: Patrice Chotard <patrice.chotard@st.com>
Date: Tue, 28 Mar 2017 14:35:42 +0200
Subject: [PATCH 04/16] dm: usb: Add a uclass for USB PHY

This is a basic implementation of USB PHY which
define a standard API that link USB PHY client to
USB PHY driver controller.

Signed-off-by: Patrice Chotard <patrice.chotard@st.com>
---
 drivers/usb/Kconfig              |   4 ++
 drivers/usb/phy/Kconfig          |  10 ++++
 drivers/usb/phy/Makefile         |   1 +
 drivers/usb/phy/usb_phy_uclass.c |  90 +++++++++++++++++++++++++++++++
 include/dm/uclass-id.h           |   1 +
 include/usb_phy-uclass.h         |  42 +++++++++++++++
 include/usb_phy.h                | 112 +++++++++++++++++++++++++++++++++++++++
 7 files changed, 260 insertions(+)
 create mode 100644 drivers/usb/phy/Kconfig
 create mode 100644 drivers/usb/phy/usb_phy_uclass.c
 create mode 100644 include/usb_phy-uclass.h
 create mode 100644 include/usb_phy.h

diff --git a/drivers/usb/Kconfig b/drivers/usb/Kconfig
index da3ec2fa75..e30c9d6273 100644
--- a/drivers/usb/Kconfig
+++ b/drivers/usb/Kconfig
@@ -94,4 +94,8 @@ endif
 
 source "drivers/usb/gadget/Kconfig"
 
+comment "USB PHY"
+
+source "drivers/usb/phy/Kconfig"
+
 endif
diff --git a/drivers/usb/phy/Kconfig b/drivers/usb/phy/Kconfig
new file mode 100644
index 0000000000..0539401c29
--- /dev/null
+++ b/drivers/usb/phy/Kconfig
@@ -0,0 +1,10 @@
+menu "USB PHY drivers"
+
+config USB_PHY
+	bool "Enable driver model for USB PHY drivers"
+	depends on DM
+	help
+	  Enable driver model for USB PHY access. It defines basic
+	  init and exit API.
+
+endmenu
diff --git a/drivers/usb/phy/Makefile b/drivers/usb/phy/Makefile
index 4e548c24ec..5314dcbc58 100644
--- a/drivers/usb/phy/Makefile
+++ b/drivers/usb/phy/Makefile
@@ -5,6 +5,7 @@
 # SPDX-License-Identifier:	GPL-2.0+
 #
 
+obj-$(CONFIG_USB_PHY) += usb_phy_uclass.o
 obj-$(CONFIG_TWL4030_USB) += twl4030.o
 obj-$(CONFIG_OMAP_USB_PHY) += omap_usb_phy.o
 obj-$(CONFIG_ROCKCHIP_USB2_PHY) += rockchip_usb2_phy.o
diff --git a/drivers/usb/phy/usb_phy_uclass.c b/drivers/usb/phy/usb_phy_uclass.c
new file mode 100644
index 0000000000..11da635f1d
--- /dev/null
+++ b/drivers/usb/phy/usb_phy_uclass.c
@@ -0,0 +1,90 @@
+/*
+ * Copyright (c) 2017
+ * Patrice Chotard <patrice.chotard@st.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <usb_phy-uclass.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+static inline struct usb_phy_ops *usb_phy_dev_ops(struct udevice *dev)
+{
+	return (struct usb_phy_ops *)dev->driver->ops;
+}
+
+int usb_phy_get_by_index(struct udevice *dev, int index,
+			 struct usb_phy_desc *usb_phy_desc)
+{
+	struct fdtdec_phandle_args args;
+	int ret;
+	struct udevice *dev_usb_phy;
+
+	debug("%s(dev=%p, index=%d, usb_phy_desc=%p)\n", __func__, dev, index,
+	      usb_phy_desc);
+
+	ret = fdtdec_parse_phandle_with_args(gd->fdt_blob, dev_of_offset(dev),
+					     "phys", "#phy-cells", 0,
+					     index, &args);
+	if (ret) {
+		debug("%s: fdtdec_parse_phandle_with_args failed: %d\n",
+		      __func__, ret);
+		return ret;
+	}
+
+	ret = uclass_get_device_by_of_offset(UCLASS_USB_PHY, args.node,
+					     &dev_usb_phy);
+	if (ret) {
+		debug("%s: uclass_get_device_by_of_offset failed: %d\n",
+		      __func__, ret);
+		return ret;
+	}
+
+	usb_phy_desc->dev = dev_usb_phy;
+
+	return 0;
+}
+
+int usb_phy_get_by_name(struct udevice *dev, const char *name,
+			struct usb_phy_desc *usb_phy_desc)
+{
+	int index;
+
+	debug("%s(dev=%p, name=%s, usb_phy_desc=%p)\n", __func__, dev, name,
+	      usb_phy_desc);
+
+	index = fdt_stringlist_search(gd->fdt_blob, dev_of_offset(dev),
+				      "phy-names", name);
+	if (index < 0) {
+		debug("fdt_stringlist_search() failed: %d\n", index);
+		return index;
+	}
+
+	return usb_phy_get_by_index(dev, index, usb_phy_desc);
+}
+
+int usb_phy_init(struct usb_phy_desc *usb_phy_desc)
+{
+	struct usb_phy_ops *ops = usb_phy_dev_ops(usb_phy_desc->dev);
+
+	debug("%s(usb_phy_desc=%p)\n", __func__, usb_phy_desc);
+
+	return ops->init(usb_phy_desc);
+}
+
+int usb_phy_exit(struct usb_phy_desc *usb_phy_desc)
+{
+	struct usb_phy_ops *ops = usb_phy_dev_ops(usb_phy_desc->dev);
+
+	debug("%s(usb_phy_desc=%p)\n", __func__, usb_phy_desc);
+
+	return ops->exit(usb_phy_desc);
+}
+
+UCLASS_DRIVER(usb_phy) = {
+	.id	= UCLASS_USB_PHY,
+	.name	= "usb_phy",
+};
diff --git a/include/dm/uclass-id.h b/include/dm/uclass-id.h
index 8c92d0b030..feb6689aa1 100644
--- a/include/dm/uclass-id.h
+++ b/include/dm/uclass-id.h
@@ -80,6 +80,7 @@ enum uclass_id {
 	UCLASS_USB,		/* USB bus */
 	UCLASS_USB_DEV_GENERIC,	/* USB generic device */
 	UCLASS_USB_HUB,		/* USB hub */
+	UCLASS_USB_PHY,		/* USB Phy */
 	UCLASS_VIDEO,		/* Video or LCD device */
 	UCLASS_VIDEO_BRIDGE,	/* Video bridge, e.g. DisplayPort to LVDS */
 	UCLASS_VIDEO_CONSOLE,	/* Text console driver for video device */
diff --git a/include/usb_phy-uclass.h b/include/usb_phy-uclass.h
new file mode 100644
index 0000000000..07a134c81c
--- /dev/null
+++ b/include/usb_phy-uclass.h
@@ -0,0 +1,42 @@
+/*
+ * Copyright (c) 2017
+ * Patrice Chotard <patrice.chotard@st.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _USB_PHY_UCLASS_H
+#define _USB_PHY_UCLASS_H
+
+/* See usb_phy.h for background documentation. */
+
+#include <usb_phy.h>
+
+struct udevice;
+
+/**
+ * struct usb_phy_ops - The functions that a usb_phy controller driver must
+ * implement.
+ */
+struct usb_phy_ops {
+	/**
+	 * init - operations to be performed for USB PHY initialisation
+	 *
+	 * Typically, registers init and reset deassertion
+	 *
+	 * @usb_phy_desc: The usb_phy struct to init;
+	 * @return 0 if OK, or a negative error code.
+	 */
+	int (*init)(struct usb_phy_desc *usb_phy_desc);
+	/**
+	 * exit - operations to be performed while exiting
+	 *
+	 * Typically reset assertion
+	 *
+	 * @usb_phy_desc: The usb_phy to free.
+	 * @return 0 if OK, or a negative error code.
+	 */
+	int (*exit)(struct usb_phy_desc *usb_phy_desc);
+};
+
+#endif
diff --git a/include/usb_phy.h b/include/usb_phy.h
new file mode 100644
index 0000000000..c2ddf8fbf1
--- /dev/null
+++ b/include/usb_phy.h
@@ -0,0 +1,112 @@
+/*
+ * Copyright (c) 2017
+ * Patrice Chotard <patrice.chotard@st.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _USB_PHY_H
+#define _USB_PHY_H
+
+#include <linux/errno.h>
+
+struct udevice;
+
+/**
+ * struct usb_phy_desc - A handle to a USB PHY.
+ *
+ * Clients provide storage for reset control handles. The content of the
+ * structure is managed solely by the reset API and reset drivers. A reset
+ * control struct is initialized by "get"ing the reset control struct. The
+ * reset control struct is passed to all other reset APIs to identify which
+ * reset signal to operate upon.
+ *
+ * @dev: The device which implements the reset signal.
+ *
+ */
+struct usb_phy_desc {
+	struct udevice *dev;
+};
+
+#ifdef CONFIG_DM_RESET
+/**
+ * reset_get_by_index - Get/request a USB PHY by integer index.
+ *
+ * This looks up and requests a USB PHY. The index is relative to the
+ * client device; each device is assumed to have n USB PHY associated
+ * with it somehow, and this function finds and requests one of them.
+ *
+ * @dev:	  The client device.
+ * @index:	  The index of the USB PHY to request, within the client's
+ *		  list of USB PHYs.
+ * @usb_phy_desc  A pointer to a USB PHY struct to initialize.
+ * @return 0 if OK, or a negative error code.
+ */
+int usb_phy_get_by_index(struct udevice *dev, int index,
+			 struct usb_phy_desc *usb_phy_desc);
+
+/**
+ * usb_phy_get_by_name - Get/request a USB PHY by name.
+ *
+ * This looks up and requests a USB PHY. The name is relative to the
+ * client device; each device is assumed to have n USB PHY associated
+ * with it somehow, and this function finds and requests one of them.
+ *
+ * @dev:	  The client device.
+ * @name:	  The name of the USB PHY to request, within the client's
+ *		  list of USB PHYs.
+ * @usb_phy_desc: A pointer to a USB PHY struct to initialize.
+ * @return 0 if OK, or a negative error code.
+ */
+int usb_phy_get_by_name(struct udevice *dev, const char *name,
+			struct usb_phy_desc *usb_phy_desc);
+
+/**
+ * init - Initialize a USB PHY.
+ *
+ * Typically initialize PHY specific registers
+ * and deassert USB PHY associated reset signals.
+ *
+ * @usb_phy_desc: A USB PHY struct that was previously successfully
+ *		  requested by reset_get_by_*().
+ * @return 0 if OK, or a negative error code.
+ */
+int usb_phy_init(struct usb_phy_desc *usb_phy_desc);
+
+/**
+ * exit - operations to be performed while exiting
+ *
+ * Typically deassert USB PHY associated reset signals.
+ *
+ * @usb_phy_desc: A USB PHY struct that was previously successfully
+ *		  requested by reset_get_by_*().
+ * @return 0 if OK, or a negative error code.
+ */
+int usb_phy_exit(struct usb_phy_desc *usb_phy_desc);
+
+#else
+static inline int usb_phy_get_by_index(struct udevice *dev, int index,
+				     struct usb_phy_desc *usb_phy_desc)
+{
+	return -ENOTSUPP;
+}
+
+static inline int usb_phy_get_by_name(struct udevice *dev, const char *name,
+				    struct usb_phy_desc *usb_phy_desc)
+{
+	return -ENOTSUPP;
+}
+
+static inline int init(struct usb_phy_desc *usb_phy_desc)
+{
+	return 0;
+}
+
+static inline int exit(struct usb_phy_desc *usb_phy_desc)
+{
+	return 0;
+}
+
+#endif
+
+#endif
-- 
2.12.2

From 6c1aa774cc65570b245885c1a2d7059dacc57eb2 Mon Sep 17 00:00:00 2001
From: Patrice Chotard <patrice.chotard@st.com>
Date: Tue, 28 Mar 2017 14:47:30 +0200
Subject: [PATCH 05/16] usb: phy: Add STi USB2 PHY

This is the generic phy driver for the picoPHY ports
used by USB2/1.1 controllers. It is found on STiH407 SoC
family from STMicroelectronics.

Signed-off-by: Patrice Chotard <patrice.chotard@st.com>
---
 doc/device-tree-bindings/phy/phy-stih407-usb.txt |  24 +++
 drivers/usb/phy/Kconfig                          |   9 ++
 drivers/usb/phy/Makefile                         |   1 +
 drivers/usb/phy/sti_usb_phy.c                    | 181 +++++++++++++++++++++++
 4 files changed, 215 insertions(+)
 create mode 100644 doc/device-tree-bindings/phy/phy-stih407-usb.txt
 create mode 100644 drivers/usb/phy/sti_usb_phy.c

diff --git a/doc/device-tree-bindings/phy/phy-stih407-usb.txt b/doc/device-tree-bindings/phy/phy-stih407-usb.txt
new file mode 100644
index 0000000000..de6a706abc
--- /dev/null
+++ b/doc/device-tree-bindings/phy/phy-stih407-usb.txt
@@ -0,0 +1,24 @@
+ST STiH407 USB PHY controller
+
+This file documents the dt bindings for the usb picoPHY driver which is the PHY for both USB2 and USB3
+host controllers (when controlling usb2/1.1 devices) available on STiH407 SoC family from STMicroelectronics.
+
+Required properties:
+- compatible		: should be "st,stih407-usb2-phy"
+- st,syscfg		: phandle of sysconfig bank plus integer array containing phyparam and phyctrl register offsets
+- resets		: list of phandle and reset specifier pairs. There should be two entries, one
+			  for the whole phy and one for the port
+- reset-names		: list of reset signal names. Should be "global" and "port"
+See: Documentation/devicetree/bindings/reset/st,sti-powerdown.txt
+See: Documentation/devicetree/bindings/reset/reset.txt
+
+Example:
+
+usb2_picophy0: usbpicophy@f8 {
+	compatible	= "st,stih407-usb2-phy";
+	#phy-cells	= <0>;
+	st,syscfg	= <&syscfg_core 0x100 0xf4>;
+	resets		= <&softreset STIH407_PICOPHY_SOFTRESET>,
+			  <&picophyreset STIH407_PICOPHY0_RESET>;
+	reset-names	= "global", "port";
+};
diff --git a/drivers/usb/phy/Kconfig b/drivers/usb/phy/Kconfig
index 0539401c29..98c1995282 100644
--- a/drivers/usb/phy/Kconfig
+++ b/drivers/usb/phy/Kconfig
@@ -7,4 +7,13 @@ config USB_PHY
 	  Enable driver model for USB PHY access. It defines basic
 	  init and exit API.
 
+config STI_USB_PHY
+	bool "STMicroelectronics USB2 picoPHY driver for STiH407 family"
+	depends on USB_PHY
+	default y if ARCH_STI
+	help
+	  This is the generic phy driver for the picoPHY ports
+	  used by USB2 and USB3 Host controllers available on
+	  STiH407 SoC families.
+
 endmenu
diff --git a/drivers/usb/phy/Makefile b/drivers/usb/phy/Makefile
index 5314dcbc58..584cc9672e 100644
--- a/drivers/usb/phy/Makefile
+++ b/drivers/usb/phy/Makefile
@@ -9,3 +9,4 @@ obj-$(CONFIG_USB_PHY) += usb_phy_uclass.o
 obj-$(CONFIG_TWL4030_USB) += twl4030.o
 obj-$(CONFIG_OMAP_USB_PHY) += omap_usb_phy.o
 obj-$(CONFIG_ROCKCHIP_USB2_PHY) += rockchip_usb2_phy.o
+obj-$(CONFIG_STI_USB_PHY) += sti_usb_phy.o
diff --git a/drivers/usb/phy/sti_usb_phy.c b/drivers/usb/phy/sti_usb_phy.c
new file mode 100644
index 0000000000..905824602b
--- /dev/null
+++ b/drivers/usb/phy/sti_usb_phy.c
@@ -0,0 +1,181 @@
+/*
+ * Copyright (c) 2017
+ * Patrice Chotard <patrice.chotard@st.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <bitfield.h>
+#include <dm.h>
+#include <errno.h>
+#include <fdtdec.h>
+#include <libfdt.h>
+#include <regmap.h>
+#include <reset-uclass.h>
+#include <syscon.h>
+#include <usb_phy-uclass.h>
+#include <wait_bit.h>
+
+#include <linux/bitops.h>
+#include <linux/compat.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+/* Default PHY_SEL and REFCLKSEL configuration */
+#define STIH407_USB_PICOPHY_CTRL_PORT_CONF	0x6
+
+/* ports parameters overriding */
+#define STIH407_USB_PICOPHY_PARAM_DEF		0x39a4dc
+
+#define PHYPARAM_REG	1
+#define PHYCTRL_REG	2
+#define PHYPARAM_NB	3
+
+struct sti_usb_phy {
+	struct regmap *regmap;
+	struct reset_ctl global_ctl;
+	struct reset_ctl port_ctl;
+	int param;
+	int ctrl;
+};
+
+static int sti_usb_phy_deassert(struct sti_usb_phy *phy)
+{
+	int ret;
+
+	ret = reset_deassert(&phy->global_ctl);
+	if (ret < 0) {
+		error("PHY global deassert failed: %d", ret);
+		return ret;
+	}
+
+	ret = reset_deassert(&phy->port_ctl);
+	if (ret < 0)
+		error("PHY port deassert failed: %d", ret);
+
+	return ret;
+}
+
+static int sti_usb_phy_init(struct usb_phy_desc *usb_phy_desc)
+{
+	struct udevice *dev = usb_phy_desc->dev;
+	struct sti_usb_phy *phy = dev_get_priv(dev);
+	void __iomem *reg;
+
+	/* set ctrl picophy value */
+	reg = (void __iomem *)phy->regmap->base + phy->ctrl;
+	/* CTRL_PORT mask is 0x1f */
+	clrsetbits_le32(reg, 0x1f, STIH407_USB_PICOPHY_CTRL_PORT_CONF);
+
+	/* set ports parameters overriding */
+	reg = (void __iomem *)phy->regmap->base + phy->param;
+	/* PARAM_DEF mask is 0xffffffff */
+	clrsetbits_le32(reg, 0xffffffff, STIH407_USB_PICOPHY_PARAM_DEF);
+
+	return sti_usb_phy_deassert(phy);
+}
+
+static int sti_usb_phy_exit(struct usb_phy_desc *usb_phy_desc)
+{
+	struct udevice *dev = usb_phy_desc->dev;
+	struct sti_usb_phy *phy = dev_get_priv(dev);
+	int ret;
+
+	ret = reset_deassert(&phy->port_ctl);
+	if (ret < 0) {
+		error("PHY port deassert failed: %d", ret);
+		return ret;
+	}
+
+	ret = reset_deassert(&phy->global_ctl);
+	if (ret < 0)
+		error("PHY global deassert failed: %d", ret);
+
+	return ret;
+}
+
+struct usb_phy_ops sti_usb_phy_ops = {
+	.init = sti_usb_phy_init,
+	.exit = sti_usb_phy_exit,
+};
+
+int sti_usb_phy_probe(struct udevice *dev)
+{
+	struct sti_usb_phy *priv = dev_get_priv(dev);
+	struct udevice *syscon;
+	struct fdtdec_phandle_args syscfg_phandle;
+	u32 cells[PHYPARAM_NB];
+	int ret, count;
+
+	/* get corresponding syscon phandle */
+	ret = fdtdec_parse_phandle_with_args(gd->fdt_blob, dev->of_offset,
+					     "st,syscfg", NULL, 0, 0,
+					     &syscfg_phandle);
+	if (ret < 0) {
+		error("Can't get syscfg phandle: %d\n", ret);
+		return ret;
+	}
+
+	ret = uclass_get_device_by_of_offset(UCLASS_SYSCON, syscfg_phandle.node,
+					     &syscon);
+	if (ret) {
+		error("unable to find syscon device (%d)\n", ret);
+		return ret;
+	}
+
+	priv->regmap = syscon_get_regmap(syscon);
+	if (!priv->regmap) {
+		error("unable to find regmap\n");
+		return -ENODEV;
+	}
+
+	/* get phy param offset */
+	count = fdtdec_get_int_array_count(gd->fdt_blob, dev->of_offset,
+					   "st,syscfg", cells,
+					   ARRAY_SIZE(cells));
+
+	if (count < 0) {
+		error("Bad PHY st,syscfg property %d\n", count);
+		return -EINVAL;
+	}
+
+	if (count > PHYPARAM_NB) {
+		error("Unsupported PHY param count %d\n", count);
+		return -EINVAL;
+	}
+
+	priv->param = cells[PHYPARAM_REG];
+	priv->ctrl = cells[PHYCTRL_REG];
+
+	/* get global reset control */
+	ret = reset_get_by_name(dev, "global", &priv->global_ctl);
+	if (ret) {
+		error("can't get global reset for %s (%d)", dev->name, ret);
+		return ret;
+	}
+
+	/* get port reset control */
+	ret = reset_get_by_name(dev, "port", &priv->port_ctl);
+	if (ret) {
+		error("can't get port reset for %s (%d)", dev->name, ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static const struct udevice_id sti_usb_phy_ids[] = {
+	{ .compatible = "st,stih407-usb2-phy" },
+	{ }
+};
+
+U_BOOT_DRIVER(sti_usb_phy) = {
+	.name = "sti_usb_phy",
+	.id = UCLASS_USB_PHY,
+	.of_match = sti_usb_phy_ids,
+	.probe = sti_usb_phy_probe,
+	.ops = &sti_usb_phy_ops,
+	.priv_auto_alloc_size = sizeof(struct sti_usb_phy),
+};
-- 
2.12.2

From 04154023ccd7b08cbc5dfcd7321dae7505b53850 Mon Sep 17 00:00:00 2001
From: Patrice Chotard <patrice.chotard@st.com>
Date: Fri, 17 Mar 2017 14:40:27 +0100
Subject: [PATCH 06/16] usb: ehci: Add STi ehci support

Add support for on-chip ehci controller available
on STMicrolectronics SoCs.
ehci support will be then available on both type A
USB 2.0 connectors.

Signed-off-by: Patrice Chotard <patrice.chotard@st.com>
---
 drivers/usb/host/Kconfig    |   9 ++++
 drivers/usb/host/Makefile   |   1 +
 drivers/usb/host/ehci-sti.c | 116 ++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 126 insertions(+)
 create mode 100644 drivers/usb/host/ehci-sti.c

diff --git a/drivers/usb/host/Kconfig b/drivers/usb/host/Kconfig
index 0bf8274405..7c29bf5c80 100644
--- a/drivers/usb/host/Kconfig
+++ b/drivers/usb/host/Kconfig
@@ -121,6 +121,15 @@ config USB_EHCI_MSM
 	  This driver supports combination of Chipidea USB controller
 	  and Synapsys USB PHY in host mode only.
 
+config USB_EHCI_STI
+	bool "Support for STMicroelectronics on-chip EHCI USB controller"
+	depends on ARCH_STI
+	select STI_PHY_USB
+	default y
+	---help---
+	  Enables support for the on-chip EHCI controller on
+	  STMicroelectronics SoCs.
+
 config USB_EHCI_ZYNQ
 	bool "Support for Xilinx Zynq on-chip EHCI USB controller"
 	depends on ARCH_ZYNQ
diff --git a/drivers/usb/host/Makefile b/drivers/usb/host/Makefile
index 58c0cf54c2..303aa32fbe 100644
--- a/drivers/usb/host/Makefile
+++ b/drivers/usb/host/Makefile
@@ -46,6 +46,7 @@ obj-$(CONFIG_USB_EHCI_MARVELL) += ehci-marvell.o
 obj-$(CONFIG_USB_EHCI_MSM) += ehci-msm.o
 obj-$(CONFIG_USB_EHCI_PCI) += ehci-pci.o
 obj-$(CONFIG_USB_EHCI_SPEAR) += ehci-spear.o
+obj-$(CONFIG_USB_EHCI_STI) += ehci-sti.o
 obj-$(CONFIG_USB_EHCI_SUNXI) += ehci-sunxi.o
 obj-$(CONFIG_USB_EHCI_TEGRA) += ehci-tegra.o
 obj-$(CONFIG_USB_EHCI_VCT) += ehci-vct.o
diff --git a/drivers/usb/host/ehci-sti.c b/drivers/usb/host/ehci-sti.c
new file mode 100644
index 0000000000..b4171704c0
--- /dev/null
+++ b/drivers/usb/host/ehci-sti.c
@@ -0,0 +1,116 @@
+/*
+ * Copyright (c) 2017
+ * Patrice Chotard <patrice.chotard@st.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <dm.h>
+#include <errno.h>
+#include "ehci.h"
+#include <reset-uclass.h>
+#include <usb.h>
+#include <usb_phy.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+struct sti_ehci_priv {
+	struct ehci_ctrl ctrl;
+	struct reset_ctl power_ctl;
+	struct reset_ctl softreset_ctl;
+	struct usb_phy_desc usb_phy;
+};
+
+static int sti_ehci_probe(struct udevice *dev)
+{
+	struct sti_ehci_priv *priv = dev_get_priv(dev);
+	struct ehci_hccr *hccr = priv->ctrl.hccr;
+	struct ehci_hcor *hcor;
+	int ret;
+
+	hccr = (struct ehci_hccr *)dev_get_addr(dev);
+
+	if (hccr == (void *)FDT_ADDR_T_NONE)
+		return -EINVAL;
+
+	ret = reset_get_by_name(dev, "power", &priv->power_ctl);
+	if (ret) {
+		error("can't get power for %s: %d", dev->name, ret);
+		return ret;
+	}
+
+	ret = reset_get_by_name(dev, "softreset", &priv->softreset_ctl);
+	if (ret) {
+		error("can't get soft reset for %s: %d", dev->name, ret);
+		return ret;
+	}
+
+	ret = usb_phy_get_by_name(dev, "usb", &priv->usb_phy);
+	if (ret) {
+		error("USB PHY DT node not found for %s: %d", dev->name, ret);
+		return ret;
+	}
+
+	ret = reset_deassert(&priv->softreset_ctl);
+	if (ret < 0) {
+		error("EHCI soft reset deassert failed: %d", ret);
+		return ret;
+	}
+
+	ret = reset_deassert(&priv->power_ctl);
+	if (ret < 0) {
+		error("EHCI power deassert failed: %d", ret);
+		return ret;
+	}
+
+	ret = usb_phy_init(&priv->usb_phy);
+	if (ret) {
+		error("Can't init USB PHY for %s: %d\n", dev->name, ret);
+		return ret;
+	}
+
+	hcor = (struct ehci_hcor *)((phys_addr_t)hccr +
+			HC_LENGTH(ehci_readl(&(hccr)->cr_capbase)));
+
+	return ehci_register(dev, hccr, hcor, NULL, 0, USB_INIT_HOST);
+}
+
+static int sti_ehci_remove(struct udevice *dev)
+{
+	struct sti_ehci_priv *priv = dev_get_priv(dev);
+	int ret;
+
+	ret = ehci_deregister(dev);
+	if (ret)
+		return ret;
+
+	ret = reset_assert(&priv->power_ctl);
+	if (ret < 0) {
+		error("EHCI power assert failed: %d", ret);
+		return ret;
+	}
+
+	ret = reset_assert(&priv->softreset_ctl);
+	if (ret < 0)
+		error("EHCI soft reset assert failed: %d", ret);
+
+	return ret;
+}
+
+static const struct udevice_id sti_usb_ids[] = {
+	{ .compatible = "st,st-ehci-300x" },
+	{ }
+};
+
+U_BOOT_DRIVER(ehci_sti) = {
+	.name = "ehci_sti",
+	.id = UCLASS_USB,
+	.of_match = sti_usb_ids,
+	.probe = sti_ehci_probe,
+	.remove = sti_ehci_remove,
+	.ops = &ehci_usb_ops,
+	.priv_auto_alloc_size = sizeof(struct sti_ehci_priv),
+	.flags	= DM_FLAG_ALLOC_PRIV_DMA,
+};
-- 
2.12.2

From 93cfa25edb32da2b3fa9ba02de58bcc64cdf09fe Mon Sep 17 00:00:00 2001
From: Patrice Chotard <patrice.chotard@st.com>
Date: Mon, 20 Mar 2017 13:38:41 +0100
Subject: [PATCH 07/16] usb: ohci: Add STi ohci support

Add support for on-chip ohci controller available
on STMicrolectronics SoCs.
Ohci support will be then available on both type A
USB 2.0 connectors.

Signed-off-by: Patrice Chotard <patrice.chotard@st.com>
---
 drivers/usb/host/Kconfig    |  9 +++++
 drivers/usb/host/Makefile   |  1 +
 drivers/usb/host/ohci-sti.c | 93 +++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 103 insertions(+)
 create mode 100644 drivers/usb/host/ohci-sti.c

diff --git a/drivers/usb/host/Kconfig b/drivers/usb/host/Kconfig
index 7c29bf5c80..b259a05ca3 100644
--- a/drivers/usb/host/Kconfig
+++ b/drivers/usb/host/Kconfig
@@ -169,6 +169,15 @@ config USB_OHCI_GENERIC
 	---help---
 	  Enables support for generic OHCI controller.
 
+config USB_OHCI_STI
+	bool "Support for STMicroelectronics OHCI USB controller"
+	depends on ARCH_STI
+	depends on OF_CONTROL
+	depends on DM_USB
+	select USB_HOST
+	---help---
+	  Enables support for the on-chip OHCI controller on STMicroelectronics SoCs.
+
 endif # USB_OHCI_HCD
 
 config USB_UHCI_HCD
diff --git a/drivers/usb/host/Makefile b/drivers/usb/host/Makefile
index 303aa32fbe..b78e632214 100644
--- a/drivers/usb/host/Makefile
+++ b/drivers/usb/host/Makefile
@@ -22,6 +22,7 @@ obj-$(CONFIG_USB_OHCI_EP93XX) += ohci-ep93xx.o
 obj-$(CONFIG_USB_OHCI_SUNXI) += ohci-sunxi.o
 obj-$(CONFIG_USB_OHCI_LPC32XX) += ohci-lpc32xx.o
 obj-$(CONFIG_USB_OHCI_GENERIC) += ohci-generic.o
+obj-$(CONFIG_USB_OHCI_STI) += ohci-sti.o
 
 # echi
 obj-$(CONFIG_USB_EHCI) += ehci-hcd.o
diff --git a/drivers/usb/host/ohci-sti.c b/drivers/usb/host/ohci-sti.c
new file mode 100644
index 0000000000..c221313409
--- /dev/null
+++ b/drivers/usb/host/ohci-sti.c
@@ -0,0 +1,93 @@
+/*
+ * Copyright (c) 2017
+ * Patrice Chotard <patrice.chotard@st.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <dm.h>
+#include <errno.h>
+#include "ohci.h"
+#include <reset-uclass.h>
+#include <usb.h>
+#include <usb_phy.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#if !defined(CONFIG_USB_OHCI_NEW)
+# error "Generic OHCI driver requires CONFIG_USB_OHCI_NEW"
+#endif
+
+struct sti_ohci_priv {
+	ohci_t ohci;
+	struct reset_ctl power_ctl;
+	struct reset_ctl softreset_ctl;
+	struct usb_phy_desc usb_phy;
+};
+
+static int ohci_usb_probe(struct udevice *dev)
+{
+	struct sti_ohci_priv *priv = dev_get_priv(dev);
+	struct ohci_regs *regs;
+	int ret;
+
+	regs = (struct ohci_regs *)dev_get_addr(dev);
+	if (regs == (void *)FDT_ADDR_T_NONE)
+		return -EINVAL;
+
+	ret = reset_get_by_name(dev, "power", &priv->power_ctl);
+	if (ret) {
+		error("can't get power reset for %s (%d)", dev->name, ret);
+		return ret;
+	}
+
+	ret = reset_get_by_name(dev, "softreset", &priv->softreset_ctl);
+	if (ret) {
+		error("can't get USB PHY for %s (%d)", dev->name, ret);
+		return ret;
+	}
+
+	ret = usb_phy_get_by_name(dev, "usb", &priv->usb_phy);
+	if (ret) {
+		error("can't get soft reset for %s (%d)", dev->name, ret);
+		return ret;
+	}
+
+	ret = reset_deassert(&priv->power_ctl);
+	if (ret < 0) {
+		error("OHCI power reset deassert failed: %d", ret);
+		return ret;
+	}
+
+	ret = reset_deassert(&priv->softreset_ctl);
+	if (ret < 0) {
+		error("OHCI soft reset deassert failed: %d", ret);
+		return ret;
+	}
+
+	ret = usb_phy_init(&priv->usb_phy);
+	if (ret) {
+		error("Can't init USB PHY\n");
+		return ret;
+	}
+
+	return ohci_register(dev, regs);
+}
+
+static const struct udevice_id sti_usb_ids[] = {
+	{ .compatible = "st,st-ohci-300x" },
+	{ }
+};
+
+U_BOOT_DRIVER(ohci_sti) = {
+	.name = "ohci_sti",
+	.id = UCLASS_USB,
+	.of_match = sti_usb_ids,
+	.probe = ohci_usb_probe,
+	.remove = ohci_deregister,
+	.ops = &ohci_usb_ops,
+	.priv_auto_alloc_size = sizeof(struct sti_ohci_priv),
+	.flags = DM_FLAG_ALLOC_PRIV_DMA,
+};
-- 
2.12.2

From 47d42b930529f77bd90f30a7d20cc0e32e1efcfa Mon Sep 17 00:00:00 2001
From: Patrice Chotard <patrice.chotard@st.com>
Date: Tue, 28 Mar 2017 15:33:28 +0200
Subject: [PATCH 08/16] usb: xhci: Add STi xhci support

Add support for on-chip DWC3 controller available
on STMicrolectronics STiH407 family SoCs.
On B2260 board, the type AB USB connector is managed
by a DWC3 IP. As USB3 signals are not wired, only USB2
is supported.

Signed-off-by: Patrice Chotard <patrice.chotard@st.com>
---
 drivers/usb/host/Kconfig    |   8 ++++
 drivers/usb/host/Makefile   |   1 +
 drivers/usb/host/xhci-sti.c | 114 ++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 123 insertions(+)
 create mode 100644 drivers/usb/host/xhci-sti.c

diff --git a/drivers/usb/host/Kconfig b/drivers/usb/host/Kconfig
index b259a05ca3..62dc5b6f6e 100644
--- a/drivers/usb/host/Kconfig
+++ b/drivers/usb/host/Kconfig
@@ -38,6 +38,14 @@ config USB_XHCI_ROCKCHIP
 	help
 	  Enables support for the on-chip xHCI controller on Rockchip SoCs.
 
+config USB_XHCI_STI
+	bool "Support for STMicroelectronics STiH407 family on-chip xHCI USB controller"
+	depends on ARCH_STI
+	default y
+	help
+	  Enables support for the on-chip xHCI controller on STMicroelectronics
+	  STiH407 family SoCs.
+
 config USB_XHCI_ZYNQMP
 	bool "Support for Xilinx ZynqMP on-chip xHCI USB controller"
 	depends on ARCH_ZYNQMP
diff --git a/drivers/usb/host/Makefile b/drivers/usb/host/Makefile
index b78e632214..40ff830673 100644
--- a/drivers/usb/host/Makefile
+++ b/drivers/usb/host/Makefile
@@ -66,6 +66,7 @@ obj-$(CONFIG_USB_XHCI_FSL) += xhci-fsl.o
 obj-$(CONFIG_USB_XHCI_MVEBU) += xhci-mvebu.o
 obj-$(CONFIG_USB_XHCI_OMAP) += xhci-omap.o
 obj-$(CONFIG_USB_XHCI_PCI) += xhci-pci.o
+obj-$(CONFIG_USB_XHCI_STI) += xhci-sti.o
 
 # designware
 obj-$(CONFIG_USB_DWC2) += dwc2.o
diff --git a/drivers/usb/host/xhci-sti.c b/drivers/usb/host/xhci-sti.c
new file mode 100644
index 0000000000..c445dc545d
--- /dev/null
+++ b/drivers/usb/host/xhci-sti.c
@@ -0,0 +1,114 @@
+/*
+ * Copyright (c) 2017
+ * Patrice Chotard <patrice.chotard@st.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/io.h>
+#include <common.h>
+#include <dm.h>
+#include <fdtdec.h>
+#include <usb.h>
+#include <usb_phy.h>
+
+#include "xhci.h"
+#include <linux/usb/dwc3.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+__weak int __board_usb_init(int index, enum usb_init_type init)
+{
+	return 0;
+}
+/*int board_usb_init(int index, enum usb_init_type init)*/
+/*        __attribute__((weak, alias("__board_usb_init")));*/
+
+struct sti_xhci_platdata {
+	struct usb_phy_desc usb_phy;
+	phys_addr_t dwc3_regs;
+};
+
+struct sti_xhci_priv {
+	struct xhci_ctrl ctrl;
+};
+
+static int sti_xhci_core_init(struct dwc3 *dwc3_reg)
+{
+	int ret;
+
+	ret = dwc3_core_init(dwc3_reg);
+	if (ret) {
+		debug("failed to initialize core\n");
+		return ret;
+	}
+
+	/* We are hard-coding DWC3 core to Host Mode */
+	dwc3_set_mode(dwc3_reg, DWC3_GCTL_PRTCAP_HOST);
+
+	return 0;
+}
+
+static int sti_xhci_ofdata_to_platdata(struct udevice *dev)
+{
+	struct sti_xhci_platdata *plat = dev_get_platdata(dev);
+	u32 reg[2];
+	int ret;
+
+	/* get the dwc3 register space base address */
+	if (fdtdec_get_int_array(gd->fdt_blob, dev_of_offset(dev), "reg", reg,
+				 ARRAY_SIZE(reg))) {
+		debug("dwc3 node has bad/missing 'reg' property\n");
+		return -FDT_ERR_NOTFOUND;
+	}
+	plat->dwc3_regs = reg[0];
+
+	ret = usb_phy_get_by_name(dev, "usb2-phy", &plat->usb_phy);
+	if (ret)
+		error("USB PHY DT node not found for %s\n", dev->name);
+
+	return 0;
+}
+
+static int sti_xhci_probe(struct udevice *dev)
+{
+	struct sti_xhci_platdata *plat = dev_get_platdata(dev);
+	struct xhci_hcor *hcor;
+	struct xhci_hccr *hccr;
+	struct dwc3 *dwc3_reg;
+	int ret;
+
+	hccr = (struct xhci_hccr *)plat->dwc3_regs;
+	hcor = (struct xhci_hcor *)((phys_addr_t)hccr +
+			HC_LENGTH(xhci_readl(&(hccr)->cr_capbase)));
+
+	ret = usb_phy_init(&plat->usb_phy);
+	if (ret) {
+		error("Can't init USB PHY for %s\n", dev->name);
+		return ret;
+	}
+
+	dwc3_reg = (struct dwc3 *)((char *)(hccr) + DWC3_REG_OFFSET);
+
+	sti_xhci_core_init(dwc3_reg);
+
+	return xhci_register(dev, hccr, hcor);
+}
+
+static const struct udevice_id sti_xhci_ids[] = {
+	{ .compatible = "snps,dwc3" },
+	{ }
+};
+
+U_BOOT_DRIVER(xhci_sti) = {
+	.name = "xhci_sti",
+	.id = UCLASS_USB,
+	.of_match = sti_xhci_ids,
+	.ofdata_to_platdata = sti_xhci_ofdata_to_platdata,
+	.probe = sti_xhci_probe,
+	.remove = xhci_deregister,
+	.ops = &xhci_usb_ops,
+	.priv_auto_alloc_size = sizeof(struct sti_xhci_priv),
+	.platdata_auto_alloc_size = sizeof(struct sti_xhci_platdata),
+	.flags = DM_FLAG_ALLOC_PRIV_DMA,
+};
-- 
2.12.2

From 17d48e44c2a2b567ee665a6a8123716ad3976c6c Mon Sep 17 00:00:00 2001
From: Patrice Chotard <patrice.chotard@st.com>
Date: Tue, 28 Mar 2017 15:43:17 +0200
Subject: [PATCH 09/16] usb: dwc3: Add dwc3 glue driver support for STi

This patch adds the ST glue logic to manage the DWC3 HC
on STiH407 SoC family. It configures the internal glue
logic and syscfg registers.

Part of this code been extracted from kernel.org driver
(drivers/usb/dwc3/dwc3-st.c)

Signed-off-by: Patrice Chotard <patrice.chotard@st.com>
---
 arch/arm/include/asm/arch-stih410/sys_proto.h |  11 +
 doc/device-tree-bindings/usb/dwc3-st.txt      |  60 ++++++
 drivers/usb/host/Makefile                     |   2 +-
 drivers/usb/host/dwc3-sti-glue.c              | 278 ++++++++++++++++++++++++++
 include/dwc3-sti-glue.h                       |  43 ++++
 5 files changed, 393 insertions(+), 1 deletion(-)
 create mode 100644 arch/arm/include/asm/arch-stih410/sys_proto.h
 create mode 100644 doc/device-tree-bindings/usb/dwc3-st.txt
 create mode 100644 drivers/usb/host/dwc3-sti-glue.c
 create mode 100644 include/dwc3-sti-glue.h

diff --git a/arch/arm/include/asm/arch-stih410/sys_proto.h b/arch/arm/include/asm/arch-stih410/sys_proto.h
new file mode 100644
index 0000000000..5c40d3b0a4
--- /dev/null
+++ b/arch/arm/include/asm/arch-stih410/sys_proto.h
@@ -0,0 +1,11 @@
+/*
+ * Copyright (c) 2017
+ * Patrice Chotard <patrice.chotard@st.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _ASM_ARCH_SYS_PROTO_H
+#define _ASM_ARCH_SYS_PROTO_H
+
+#endif /* _ASM_ARCH_SYS_PROTO_H */
diff --git a/doc/device-tree-bindings/usb/dwc3-st.txt b/doc/device-tree-bindings/usb/dwc3-st.txt
new file mode 100644
index 0000000000..a26a1397ed
--- /dev/null
+++ b/doc/device-tree-bindings/usb/dwc3-st.txt
@@ -0,0 +1,60 @@
+ST DWC3 glue logic
+
+This file documents the parameters for the dwc3-st driver.
+This driver controls the glue logic used to configure the dwc3 core on
+STiH407 based platforms.
+
+Required properties:
+ - compatible	: must be "st,stih407-dwc3"
+ - reg		: glue logic base address and USB syscfg ctrl register offset
+ - reg-names	: should be "reg-glue" and "syscfg-reg"
+ - st,syscon	: should be phandle to system configuration node which
+		  encompasses the glue registers
+ - resets	: list of phandle and reset specifier pairs. There should be two entries, one
+		  for the powerdown and softreset lines of the usb3 IP
+ - reset-names	: list of reset signal names. Names should be "powerdown" and "softreset"
+
+ - #address-cells, #size-cells : should be '1' if the device has sub-nodes
+   with 'reg' property
+
+ - pinctl-names	: A pinctrl state named "default" must be defined
+
+ - pinctrl-0	: Pin control group
+
+ - ranges	: allows valid 1:1 translation between child's address space and
+		  parent's address space
+
+Sub-nodes:
+The dwc3 core should be added as subnode to ST DWC3 glue as shown in the
+example below.
+
+NB: The dr_mode property is NOT optional for this driver, as the default value
+is "otg", which isn't supported by this SoC. Valid dr_mode values for dwc3-st are
+either "host" or "device".
+
+Example:
+
+st_dwc3: dwc3@8f94000 {
+	status		= "disabled";
+	compatible	= "st,stih407-dwc3";
+	reg		= <0x08f94000 0x1000>, <0x110 0x4>;
+	reg-names	= "reg-glue", "syscfg-reg";
+	st,syscfg	= <&syscfg_core>;
+	resets		= <&powerdown STIH407_USB3_POWERDOWN>,
+			  <&softreset STIH407_MIPHY2_SOFTRESET>;
+	reset-names	= "powerdown", "softreset";
+	#address-cells	= <1>;
+	#size-cells	= <1>;
+	pinctrl-names	= "default";
+	pinctrl-0	= <&pinctrl_usb3>;
+	ranges;
+
+	dwc3: dwc3@9900000 {
+		compatible	= "snps,dwc3";
+		reg		= <0x09900000 0x100000>;
+		interrupts	= <GIC_SPI 155 IRQ_TYPE_NONE>;
+		dr_mode		= "host";
+		phy-names	= "usb2-phy", "usb3-phy";
+		phys		= <&usb2_picophy2>, <&phy_port2 PHY_TYPE_USB3>;
+	};
+};
diff --git a/drivers/usb/host/Makefile b/drivers/usb/host/Makefile
index 40ff830673..6be40b8fb0 100644
--- a/drivers/usb/host/Makefile
+++ b/drivers/usb/host/Makefile
@@ -66,7 +66,7 @@ obj-$(CONFIG_USB_XHCI_FSL) += xhci-fsl.o
 obj-$(CONFIG_USB_XHCI_MVEBU) += xhci-mvebu.o
 obj-$(CONFIG_USB_XHCI_OMAP) += xhci-omap.o
 obj-$(CONFIG_USB_XHCI_PCI) += xhci-pci.o
-obj-$(CONFIG_USB_XHCI_STI) += xhci-sti.o
+obj-$(CONFIG_USB_XHCI_STI) += xhci-sti.o dwc3-sti-glue.o
 
 # designware
 obj-$(CONFIG_USB_DWC2) += dwc2.o
diff --git a/drivers/usb/host/dwc3-sti-glue.c b/drivers/usb/host/dwc3-sti-glue.c
new file mode 100644
index 0000000000..368d7efc3c
--- /dev/null
+++ b/drivers/usb/host/dwc3-sti-glue.c
@@ -0,0 +1,278 @@
+/*
+ * STiH407 family DWC3 specific Glue layer
+ *
+ * Copyright (c) 2017
+ * Patrice Chotard <patrice.chotard@st.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/io.h>
+#include <common.h>
+#include <dm.h>
+#include <dwc3-sti-glue.h>
+#include <errno.h>
+#include <fdtdec.h>
+#include <libfdt.h>
+#include <dm/lists.h>
+#include <regmap.h>
+#include <reset-uclass.h>
+#include <syscon.h>
+#include <usb.h>
+
+#include <linux/usb/dwc3.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+struct sti_dwc3_glue_platdata {
+	phys_addr_t syscfg_base;
+	phys_addr_t glue_base;
+	phys_addr_t syscfg_offset;
+	struct reset_ctl powerdown_ctl;
+	struct reset_ctl softreset_ctl;
+	enum usb_dr_mode mode;
+};
+
+static int sti_dwc3_glue_drd_init(struct sti_dwc3_glue_platdata *plat)
+{
+	unsigned long val;
+
+	val = readl(plat->syscfg_base + plat->syscfg_offset);
+
+	val &= USB3_CONTROL_MASK;
+
+	switch (plat->mode) {
+	case USB_DR_MODE_PERIPHERAL:
+		val &= ~(USB3_DELAY_VBUSVALID
+			| USB3_SEL_FORCE_OPMODE | USB3_FORCE_OPMODE(0x3)
+			| USB3_SEL_FORCE_DPPULLDOWN2 | USB3_FORCE_DPPULLDOWN2
+			| USB3_SEL_FORCE_DMPULLDOWN2 | USB3_FORCE_DMPULLDOWN2);
+
+		val |= USB3_DEVICE_NOT_HOST | USB3_FORCE_VBUSVALID;
+		break;
+
+	case USB_DR_MODE_HOST:
+		val &= ~(USB3_DEVICE_NOT_HOST | USB3_FORCE_VBUSVALID
+			| USB3_SEL_FORCE_OPMODE	| USB3_FORCE_OPMODE(0x3)
+			| USB3_SEL_FORCE_DPPULLDOWN2 | USB3_FORCE_DPPULLDOWN2
+			| USB3_SEL_FORCE_DMPULLDOWN2 | USB3_FORCE_DMPULLDOWN2);
+
+		val |= USB3_DELAY_VBUSVALID;
+		break;
+
+	default:
+		error("Unsupported mode of operation %d\n", plat->mode);
+		return -EINVAL;
+	}
+	return writel(val, plat->syscfg_base + plat->syscfg_offset);
+}
+
+static void sti_dwc3_glue_init(struct sti_dwc3_glue_platdata *plat)
+{
+	unsigned long reg;
+
+	reg = readl(plat->glue_base + CLKRST_CTRL);
+
+	reg |= AUX_CLK_EN | EXT_CFG_RESET_N | XHCI_REVISION;
+	reg &= ~SW_PIPEW_RESET_N;
+
+	writel(reg, plat->glue_base + CLKRST_CTRL);
+
+	/* configure mux for vbus, powerpresent and bvalid signals */
+	reg = readl(plat->glue_base + USB2_VBUS_MNGMNT_SEL1);
+
+	reg |= SEL_OVERRIDE_VBUSVALID(USB2_VBUS_UTMIOTG) |
+	       SEL_OVERRIDE_POWERPRESENT(USB2_VBUS_UTMIOTG) |
+	       SEL_OVERRIDE_BVALID(USB2_VBUS_UTMIOTG);
+
+	writel(reg, plat->glue_base + USB2_VBUS_MNGMNT_SEL1);
+
+	setbits_le32(plat->glue_base + CLKRST_CTRL, SW_PIPEW_RESET_N);
+}
+
+int sti_dwc3_init(enum usb_dr_mode mode)
+{
+	struct sti_dwc3_glue_platdata plat;
+	struct fdtdec_phandle_args syscfg_phandle;
+	struct udevice *syscon;
+	struct regmap *regmap;
+	int node, ret;
+	const void *blob = gd->fdt_blob;
+	u32 reg[4];
+
+	/* find the dwc3 node */
+	node = fdt_node_offset_by_compatible(blob, -1, "st,stih407-dwc3");
+
+	ret = fdtdec_get_int_array(blob, node, "reg", reg, ARRAY_SIZE(reg));
+	if (ret) {
+		error("unable to find st,stih407-dwc3 reg property(%d)\n", ret);
+		return ret;
+	}
+
+	plat.glue_base = reg[0];
+	plat.syscfg_offset = reg[2];
+	plat.mode = mode;
+
+	/* get corresponding syscon phandle */
+	ret = fdtdec_parse_phandle_with_args(gd->fdt_blob, node,
+					     "st,syscfg", NULL, 0, 0,
+					     &syscfg_phandle);
+	if (ret < 0) {
+		error("Can't get syscfg phandle: %d\n", ret);
+		return ret;
+	}
+
+	ret = uclass_get_device_by_of_offset(UCLASS_SYSCON, syscfg_phandle.node,
+					     &syscon);
+	if (ret) {
+		error("unable to find syscon device (%d)\n", ret);
+		return ret;
+	}
+
+	/* get syscfg-reg base address */
+	regmap = syscon_get_regmap(syscon);
+	if (!regmap) {
+		error("unable to find regmap\n");
+		return -ENODEV;
+	}
+	plat.syscfg_base = regmap->base;
+
+	sti_dwc3_glue_drd_init(&plat);
+	sti_dwc3_glue_init(&plat);
+
+	return 0;
+}
+
+static int sti_dwc3_glue_ofdata_to_platdata(struct udevice *dev)
+{
+	struct sti_dwc3_glue_platdata *plat = dev_get_platdata(dev);
+	struct fdtdec_phandle_args syscfg_phandle;
+	struct udevice *syscon;
+	struct regmap *regmap;
+	int ret;
+	u32 reg[4];
+
+	ret = fdtdec_get_int_array(gd->fdt_blob, dev_of_offset(dev),
+				   "reg", reg, ARRAY_SIZE(reg));
+	if (ret) {
+		error("unable to find st,stih407-dwc3 reg property(%d)\n", ret);
+		return ret;
+	}
+
+	plat->glue_base = reg[0];
+	plat->syscfg_offset = reg[2];
+
+	/* get corresponding syscon phandle */
+	ret = fdtdec_parse_phandle_with_args(gd->fdt_blob, dev_of_offset(dev),
+					     "st,syscfg", NULL, 0, 0,
+					     &syscfg_phandle);
+	if (ret < 0) {
+		error("Can't get syscfg phandle: %d\n", ret);
+		return ret;
+	}
+
+	ret = uclass_get_device_by_of_offset(UCLASS_SYSCON, syscfg_phandle.node,
+					     &syscon);
+	if (ret) {
+		error("unable to find syscon device (%d)\n", ret);
+		return ret;
+	}
+
+	/* get syscfg-reg base address */
+	regmap = syscon_get_regmap(syscon);
+	if (!regmap) {
+		error("unable to find regmap\n");
+		return -ENODEV;
+	}
+	plat->syscfg_base = regmap->base;
+
+	/* get powerdown reset */
+	ret = reset_get_by_name(dev, "powerdown", &plat->powerdown_ctl);
+	if (ret) {
+		error("can't get powerdown reset for %s (%d)", dev->name, ret);
+		return ret;
+	}
+
+	/* get softreset reset */
+	ret = reset_get_by_name(dev, "softreset", &plat->softreset_ctl);
+	if (ret)
+		error("can't get soft reset for %s (%d)", dev->name, ret);
+
+	return ret;
+};
+
+static int sti_dwc3_glue_bind(struct udevice *dev)
+{
+	int dwc3_node;
+
+	/* check if one subnode is present */
+	dwc3_node = fdt_first_subnode(gd->fdt_blob, dev_of_offset(dev));
+	if (dwc3_node <= 0) {
+		error("Can't find subnode for %s\n", dev->name);
+		return -ENODEV;
+	}
+
+	/* check if the subnode compatible string is the dwc3 one*/
+	if (fdt_node_check_compatible(gd->fdt_blob, dwc3_node,
+				      "snps,dwc3") != 0) {
+		error("Can't find dwc3 subnode for %s\n", dev->name);
+		return -ENODEV;
+	}
+
+	return dm_scan_fdt_dev(dev);
+}
+
+static int sti_dwc3_glue_probe(struct udevice *dev)
+{
+	struct sti_dwc3_glue_platdata *plat = dev_get_platdata(dev);
+	int ret;
+
+	/* deassert both powerdown and softreset */
+	ret = reset_deassert(&plat->powerdown_ctl);
+	if (ret < 0) {
+		error("DWC3 powerdown reset deassert failed: %d", ret);
+		return ret;
+	}
+
+	ret = reset_deassert(&plat->softreset_ctl);
+	if (ret < 0)
+		error("DWC3 soft reset deassert failed: %d", ret);
+
+	return ret;
+}
+
+static int sti_dwc3_glue_remove(struct udevice *dev)
+{
+	struct sti_dwc3_glue_platdata *plat = dev_get_platdata(dev);
+	int ret;
+
+	/* assert both powerdown and softreset */
+	ret = reset_assert(&plat->powerdown_ctl);
+	if (ret < 0) {
+		error("DWC3 powerdown reset deassert failed: %d", ret);
+		return ret;
+	}
+
+	ret = reset_assert(&plat->softreset_ctl);
+	if (ret < 0)
+		error("DWC3 soft reset deassert failed: %d", ret);
+
+	return ret;
+}
+
+static const struct udevice_id sti_dwc3_glue_ids[] = {
+	{ .compatible = "st,stih407-dwc3" },
+	{ }
+};
+
+U_BOOT_DRIVER(dwc3_sti_glue) = {
+	.name = "dwc3_sti_glue",
+	.id = UCLASS_MISC,
+	.of_match = sti_dwc3_glue_ids,
+	.ofdata_to_platdata = sti_dwc3_glue_ofdata_to_platdata,
+	.probe = sti_dwc3_glue_probe,
+	.remove = sti_dwc3_glue_remove,
+	.bind = sti_dwc3_glue_bind,
+	.platdata_auto_alloc_size = sizeof(struct sti_dwc3_glue_platdata),
+	.flags = DM_FLAG_ALLOC_PRIV_DMA,
+};
diff --git a/include/dwc3-sti-glue.h b/include/dwc3-sti-glue.h
new file mode 100644
index 0000000000..2083427188
--- /dev/null
+++ b/include/dwc3-sti-glue.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright (c) 2017
+ * Patrice Chotard <patrice.chotard@st.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __DWC3_STI_UBOOT_H_
+#define __DWC3_STI_UBOOT_H_
+
+#include <linux/usb/otg.h>
+
+/* glue registers */
+#define CLKRST_CTRL		0x00
+#define AUX_CLK_EN		BIT(0)
+#define SW_PIPEW_RESET_N	BIT(4)
+#define EXT_CFG_RESET_N		BIT(8)
+
+#define XHCI_REVISION		BIT(12)
+
+#define USB2_VBUS_MNGMNT_SEL1	0x2C
+#define USB2_VBUS_UTMIOTG	0x1
+
+#define SEL_OVERRIDE_VBUSVALID(n)	((n) << 0)
+#define SEL_OVERRIDE_POWERPRESENT(n)	((n) << 4)
+#define SEL_OVERRIDE_BVALID(n)		((n) << 8)
+
+/* Static DRD configuration */
+#define USB3_CONTROL_MASK		0xf77
+
+#define USB3_DEVICE_NOT_HOST		BIT(0)
+#define USB3_FORCE_VBUSVALID		BIT(1)
+#define USB3_DELAY_VBUSVALID		BIT(2)
+#define USB3_SEL_FORCE_OPMODE		BIT(4)
+#define USB3_FORCE_OPMODE(n)		((n) << 5)
+#define USB3_SEL_FORCE_DPPULLDOWN2	BIT(8)
+#define USB3_FORCE_DPPULLDOWN2		BIT(9)
+#define USB3_SEL_FORCE_DMPULLDOWN2	BIT(10)
+#define USB3_FORCE_DMPULLDOWN2		BIT(11)
+
+int sti_dwc3_init(enum usb_dr_mode mode);
+
+#endif /* __DWC3_STI_UBOOT_H_ */
-- 
2.12.2

From bec77a7aaeeaa5f77fc239c672aa23d7aaa481b7 Mon Sep 17 00:00:00 2001
From: Patrice Chotard <patrice.chotard@st.com>
Date: Mon, 20 Mar 2017 13:40:41 +0100
Subject: [PATCH 10/16] board: STiH410-B2260: add OHCI and XHCI related defines

Signed-off-by: Patrice Chotard <patrice.chotard@st.com>
---
 include/configs/stih410-b2260.h | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/include/configs/stih410-b2260.h b/include/configs/stih410-b2260.h
index 6f4070ff43..3df0e04768 100644
--- a/include/configs/stih410-b2260.h
+++ b/include/configs/stih410-b2260.h
@@ -52,4 +52,8 @@
 
 #define CONFIG_SKIP_LOWLEVEL_INIT
 
+#define CONFIG_USB_OHCI_NEW
+#define CONFIG_SYS_USB_OHCI_MAX_ROOT_PORTS	2
+#define CONFIG_SYS_USB_XHCI_MAX_ROOT_PORTS	2
+
 #endif /* __CONFIG_H */
-- 
2.12.2

From 172ba7069e065c6cd9b84c59dfa92d6545b34b9b Mon Sep 17 00:00:00 2001
From: Patrice Chotard <patrice.chotard@st.com>
Date: Mon, 20 Mar 2017 14:37:27 +0100
Subject: [PATCH 11/16] board: STiH410-B2260: add fastboot support

Add usb_gadget_handle_interrupts(), board_usb_init(),
board_usb_cleanup() and g_dnl_board_usb_cable_connected()
callbacks needed for FASTBOOT support

Signed-off-by: Patrice Chotard <patrice.chotard@st.com>
---
 board/st/stih410-b2260/board.c | 44 ++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 44 insertions(+)

diff --git a/board/st/stih410-b2260/board.c b/board/st/stih410-b2260/board.c
index 92b0695593..899a3e97bd 100644
--- a/board/st/stih410-b2260/board.c
+++ b/board/st/stih410-b2260/board.c
@@ -7,6 +7,9 @@
  */
 
 #include <common.h>
+#include <dwc3-sti-glue.h>
+#include <dwc3-uboot.h>
+#include <usb.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -36,3 +39,44 @@ int board_init(void)
 {
 	return 0;
 }
+
+#ifdef CONFIG_USB_DWC3
+static struct dwc3_device dwc3_device_data = {
+	.maximum_speed = USB_SPEED_HIGH,
+	.dr_mode = USB_DR_MODE_PERIPHERAL,
+	.index = 0,
+};
+
+int usb_gadget_handle_interrupts(int index)
+{
+	dwc3_uboot_handle_interrupt(index);
+	return 0;
+}
+
+int board_usb_init(int index, enum usb_init_type init)
+{
+	int node;
+	const void *blob = gd->fdt_blob;
+
+	/* find the snps,dwc3 node */
+	node = fdt_node_offset_by_compatible(blob, -1, "snps,dwc3");
+
+	dwc3_device_data.base = fdtdec_get_addr(blob, node, "reg");
+
+	/* init dwc3 glue with mode forced to PERIPHERAL */
+	sti_dwc3_init(USB_DR_MODE_PERIPHERAL);
+
+	return dwc3_uboot_init(&dwc3_device_data);
+}
+
+int board_usb_cleanup(int index, enum usb_init_type init)
+{
+	dwc3_uboot_exit(index);
+	return 0;
+}
+
+int g_dnl_board_usb_cable_connected(void)
+{
+	return 1;
+}
+#endif
-- 
2.12.2

From f6976cd38b82390054b9ff135f8346119082f2ad Mon Sep 17 00:00:00 2001
From: Patrice Chotard <patrice.chotard@st.com>
Date: Mon, 20 Mar 2017 14:38:49 +0100
Subject: [PATCH 12/16] STiH410-B2260: enable USB Host Networking

Signed-off-by: Patrice Chotard <patrice.chotard@st.com>
---
 include/configs/stih410-b2260.h | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/include/configs/stih410-b2260.h b/include/configs/stih410-b2260.h
index 3df0e04768..6c84e9b485 100644
--- a/include/configs/stih410-b2260.h
+++ b/include/configs/stih410-b2260.h
@@ -52,8 +52,20 @@
 
 #define CONFIG_SKIP_LOWLEVEL_INIT
 
+/* USB Configs */
 #define CONFIG_USB_OHCI_NEW
 #define CONFIG_SYS_USB_OHCI_MAX_ROOT_PORTS	2
 #define CONFIG_SYS_USB_XHCI_MAX_ROOT_PORTS	2
 
+#define CONFIG_USB_HOST_ETHER
+#define CONFIG_USB_ETHER_ASIX
+#define CONFIG_USB_ETHER_MCS7830
+#define CONFIG_USB_ETHER_SMSC95XX
+
+/* NET Configs */
+#define CONFIG_BOOTP_SUBNETMASK
+#define CONFIG_BOOTP_GATEWAY
+#define CONFIG_BOOTP_HOSTNAME
+#define CONFIG_BOOTP_BOOTPATH
+
 #endif /* __CONFIG_H */
-- 
2.12.2

From fe2e566d10892d0abe93cf56471caeea1facb77e Mon Sep 17 00:00:00 2001
From: Patrice Chotard <patrice.chotard@st.com>
Date: Tue, 28 Mar 2017 16:11:08 +0200
Subject: [PATCH 13/16] STiH410-B2260: enable USB, fastboot, reset related
 flags

Signed-off-by: Patrice Chotard <patrice.chotard@st.com>
---
 configs/stih410-b2260_defconfig | 36 ++++++++++++++++++++++++++++++++----
 1 file changed, 32 insertions(+), 4 deletions(-)

diff --git a/configs/stih410-b2260_defconfig b/configs/stih410-b2260_defconfig
index 4e6942f56c..b8df85c638 100644
--- a/configs/stih410-b2260_defconfig
+++ b/configs/stih410-b2260_defconfig
@@ -2,25 +2,53 @@ CONFIG_ARM=y
 CONFIG_ARCH_STI=y
 CONFIG_IDENT_STRING="STMicroelectronics STiH410-B2260"
 CONFIG_DEFAULT_DEVICE_TREE="stih410-b2260"
+CONFIG_DISTRO_DEFAULTS=y
 CONFIG_FIT=y
 CONFIG_FIT_VERBOSE=y
 # CONFIG_DISPLAY_CPUINFO is not set
 CONFIG_SYS_PROMPT="stih410-b2260 => "
+CONFIG_FASTBOOT=y
+CONFIG_USB_FUNCTION_FASTBOOT=y
+CONFIG_CMD_FASTBOOT=y
+CONFIG_ANDROID_BOOT_IMAGE=y
+CONFIG_FASTBOOT_BUF_ADDR=0x40000000
+CONFIG_FASTBOOT_BUF_SIZE=0x3DF00000
+CONFIG_FASTBOOT_FLASH=y
+CONFIG_FASTBOOT_FLASH_MMC_DEV=0
 # CONFIG_CMD_IMLS is not set
+CONFIG_CMD_GPT=y
 CONFIG_CMD_MMC=y
+CONFIG_CMD_USB=y
 CONFIG_CMD_TIME=y
 CONFIG_CMD_TIMER=y
-CONFIG_CMD_EXT2=y
-CONFIG_CMD_EXT4=y
-CONFIG_CMD_FAT=y
-CONFIG_CMD_FS_GENERIC=y
+CONFIG_CMD_EXT4_WRITE=y
+# CONFIG_ISO_PARTITION is not set
 CONFIG_OF_CONTROL=y
 CONFIG_REGMAP=y
 CONFIG_SYSCON=y
+CONFIG_MISC=y
 CONFIG_MMC_SDHCI=y
 CONFIG_MMC_SDHCI_STI=y
 CONFIG_PINCTRL=y
+CONFIG_STI_RESET=y
 CONFIG_STI_ASC_SERIAL=y
 CONFIG_SYSRESET=y
 CONFIG_TIMER=y
+CONFIG_USB=y
+CONFIG_DM_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_XHCI_DWC3=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_OHCI_HCD=y
+CONFIG_USB_OHCI_STI=y
+CONFIG_USB_DWC3=y
+CONFIG_USB_DWC3_GADGET=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="STMicroelectronics"
+CONFIG_G_DNL_VENDOR_NUM=0x483
+CONFIG_G_DNL_PRODUCT_NUM=0x7270
+CONFIG_USB_PHY=y
+CONFIG_OF_LIBFDT_OVERLAY=y
 CONFIG_SPL_OF_LIBFDT=y
-- 
2.12.2

From 552bdf8d8c4604ac7d6352ff9cb187c0d7b93021 Mon Sep 17 00:00:00 2001
From: Patrice Chotard <patrice.chotard@st.com>
Date: Wed, 22 Mar 2017 18:06:18 +0100
Subject: [PATCH 14/16] board: STiH410-B2260: update environment variable

Signed-off-by: Patrice Chotard <patrice.chotard@st.com>
---
 include/configs/stih410-b2260.h | 31 +++++++++++++++++++++++++------
 1 file changed, 25 insertions(+), 6 deletions(-)

diff --git a/include/configs/stih410-b2260.h b/include/configs/stih410-b2260.h
index 6c84e9b485..7fcb327a52 100644
--- a/include/configs/stih410-b2260.h
+++ b/include/configs/stih410-b2260.h
@@ -20,13 +20,32 @@
 
 #define CONFIG_SYS_HZ_CLOCK		1000000000	/* 1 GHz */
 
-#define CONFIG_BOOTARGS							\
-	"console=ttyS0,115200 earlyprintk consoleblank=0 ignore_loglevel"
-
+#include <config_distro_defaults.h>
 /* Environment */
-#define CONFIG_EXTRA_ENV_SETTINGS \
-	"board= B2260" \
-	"load_addr= #CONFIG_SYS_LOAD_ADDR \0"
+
+/* we assume that rootfs is located on second partition formatted in ext4 */
+#define CONFIG_BOOTARGS			\
+	"console=ttyAS1,115200 CONSOLE=/dev/ttyAS1 consoleblank=0 root=/dev/mmcblk0p2 rootfstype=ext4 rw rootwait mem=992M@0x40000000 vmalloc=256m"
+
+#define CONFIG_LOADADDR			CONFIG_SYS_LOAD_ADDR
+
+#define CONFIG_ENV_VARS_UBOOT_CONFIG
+
+#define BOOT_TARGET_DEVICES(func) \
+	func(MMC, mmc, 0) \
+	func(USB, usb, 0) \
+	func(DHCP, dhcp, na)
+#include <config_distro_bootcmd.h>
+#define CONFIG_BOOTFILE			"uImage"
+#define CONFIG_EXTRA_ENV_SETTINGS				\
+			"kernel_addr_r=0x40000000\0"		\
+			"fdtfile=stih410-b2260.dtb\0"		\
+			"fdt_addr_r=0x47000000\0"		\
+			"scriptaddr=0x50000000\0"		\
+			"fdt_high=0xffffffffffffffff\0"		\
+			"initrd_high=0xffffffffffffffff\0"	\
+			BOOTENV
+
 
 #define CONFIG_ENV_IS_NOWHERE
 #define CONFIG_ENV_SIZE 0x4000
-- 
2.12.2

From 4b762469b09955d56bf45b81af8f5d26433e933d Mon Sep 17 00:00:00 2001
From: Nicolas Le Bayon <nicolas.le.bayon@st.com>
Date: Mon, 27 Mar 2017 16:10:45 +0200
Subject: [PATCH 15/16] board: STiH410-B2260: fix sdram size

32MB are reserved for Trusted Zone purpose

Signed-off-by: Nicolas Le Bayon <nicolas.le.bayon@st.com>
---
 include/configs/stih410-b2260.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/include/configs/stih410-b2260.h b/include/configs/stih410-b2260.h
index 7fcb327a52..ccbbf32470 100644
--- a/include/configs/stih410-b2260.h
+++ b/include/configs/stih410-b2260.h
@@ -14,7 +14,7 @@
 #define CONFIG_NR_DRAM_BANKS		1
 #define PHYS_SDRAM_1			0x40000000
 #define CONFIG_SYS_SDRAM_BASE		PHYS_SDRAM_1
-#define PHYS_SDRAM_1_SIZE		0x3FE00000
+#define PHYS_SDRAM_1_SIZE		0x3E000000
 #define CONFIG_SYS_TEXT_BASE		0x7D600000
 #define CONFIG_SYS_LOAD_ADDR		PHYS_SDRAM_1	/* default load addr */
 
-- 
2.12.2

From 4cc3772e0f7c93d8b00f82cbfe493a732ecac313 Mon Sep 17 00:00:00 2001
From: Lee Jones <lee.jones@linaro.org>
Date: Thu, 30 Mar 2017 11:18:45 +0200
Subject: [PATCH 16/16] board: STiH410-B2260: set ramdisk_addr_r to 0x48000000

Signed-off-by: Lee Jones <lee.jones@linaro.org>
---
 include/configs/stih410-b2260.h | 1 +
 1 file changed, 1 insertion(+)

diff --git a/include/configs/stih410-b2260.h b/include/configs/stih410-b2260.h
index ccbbf32470..b83bef5b0e 100644
--- a/include/configs/stih410-b2260.h
+++ b/include/configs/stih410-b2260.h
@@ -44,6 +44,7 @@
 			"scriptaddr=0x50000000\0"		\
 			"fdt_high=0xffffffffffffffff\0"		\
 			"initrd_high=0xffffffffffffffff\0"	\
+			"ramdisk_addr_r=0x48000000\0"		\
 			BOOTENV
 
 
-- 
2.12.2

