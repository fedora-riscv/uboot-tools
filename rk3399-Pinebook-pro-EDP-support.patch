From b90e9d3eeded9b10be1076ccbf2a3fac55cf3e74 Mon Sep 17 00:00:00 2001
From: Peter Robinson <pbrobinson@gmail.com>
Date: Mon, 1 Feb 2021 21:14:44 +0000
Subject: [PATCH] rk3399 Pinebook pro EDP support

Signed-off-by: Peter Robinson <pbrobinson@gmail.com>
---
 arch/arm/dts/rk3399-pinebook-pro-u-boot.dtsi  |   4 +
 .../include/asm/arch-rockchip/edp_rk3288.h    |   9 +-
 .../include/asm/arch-rockchip/vop_rk3288.h    |  15 +--
 drivers/pwm/rk_pwm.c                          |   2 +-
 drivers/video/rockchip/rk_edp.c               | 103 +++++++++++++++---
 drivers/video/rockchip/rk_vop.c               |  86 ++++++++++++++-
 6 files changed, 177 insertions(+), 42 deletions(-)

diff --git a/arch/arm/dts/rk3399-pinebook-pro-u-boot.dtsi b/arch/arm/dts/rk3399-pinebook-pro-u-boot.dtsi
index 1eafb40ce3..2d87bea933 100644
--- a/arch/arm/dts/rk3399-pinebook-pro-u-boot.dtsi
+++ b/arch/arm/dts/rk3399-pinebook-pro-u-boot.dtsi
@@ -16,6 +16,10 @@
 	};
 };
 
+&edp {
+	rockchip,panel = <&edp_panel>;
+};
+
 &i2c0 {
 	u-boot,dm-pre-reloc;
 };
diff --git a/arch/arm/include/asm/arch-rockchip/edp_rk3288.h b/arch/arm/include/asm/arch-rockchip/edp_rk3288.h
index 94e5bb674f..9559813e52 100644
--- a/arch/arm/include/asm/arch-rockchip/edp_rk3288.h
+++ b/arch/arm/include/asm/arch-rockchip/edp_rk3288.h
@@ -232,8 +232,9 @@ check_member(rk3288_edp, pll_reg_5, 0xa00);
 #define PD_CH0					(0x1 << 0)
 
 /* pll_reg_1 */
-#define REF_CLK_24M				(0x1 << 1)
-#define REF_CLK_27M				(0x0 << 1)
+#define REF_CLK_24M				(0x1 << 0)
+#define REF_CLK_27M				(0x0 << 0)
+#define REF_CLK_MASK				(0x1 << 0)
 
 /* line_map */
 #define LANE3_MAP_LOGIC_LANE_0			(0x0 << 6)
@@ -296,7 +297,9 @@ check_member(rk3288_edp, pll_reg_5, 0xa00);
 
 /* int_ctl */
 #define SOFT_INT_CTRL				(0x1 << 2)
-#define INT_POL					(0x1 << 0)
+#define INT_POL1				(0x1 << 1)
+#define INT_POL0				(0x1 << 0)
+#define INT_POL					(INT_POL0 | INT_POL1)
 
 /* sys_ctl_1 */
 #define DET_STA					(0x1 << 2)
diff --git a/arch/arm/include/asm/arch-rockchip/vop_rk3288.h b/arch/arm/include/asm/arch-rockchip/vop_rk3288.h
index 52446e97c6..49a7141437 100644
--- a/arch/arm/include/asm/arch-rockchip/vop_rk3288.h
+++ b/arch/arm/include/asm/arch-rockchip/vop_rk3288.h
@@ -85,26 +85,13 @@ enum {
 	LB_RGB_1280X8 = 0x5
 };
 
-#if defined(CONFIG_ROCKCHIP_RK3399)
 enum vop_modes {
 	VOP_MODE_EDP = 0,
 	VOP_MODE_MIPI,
 	VOP_MODE_HDMI,
-	VOP_MODE_MIPI1,
-	VOP_MODE_DP,
-	VOP_MODE_NONE,
-};
-#else
-enum vop_modes {
-	VOP_MODE_EDP = 0,
-	VOP_MODE_HDMI,
 	VOP_MODE_LVDS,
-	VOP_MODE_MIPI,
-	VOP_MODE_NONE,
-	VOP_MODE_AUTO_DETECT,
-	VOP_MODE_UNKNOWN,
+	VOP_MODE_DP,
 };
-#endif
 
 /* VOP_VERSION_INFO */
 #define M_FPGA_VERSION (0xffff << 16)
diff --git a/drivers/pwm/rk_pwm.c b/drivers/pwm/rk_pwm.c
index a64fc4a052..d4b9ebe528 100644
--- a/drivers/pwm/rk_pwm.c
+++ b/drivers/pwm/rk_pwm.c
@@ -146,7 +146,7 @@ static int rk_pwm_probe(struct udevice *dev)
 	priv->data = (struct rockchip_pwm_data *)dev_get_driver_data(dev);
 
 	if (priv->data->supports_polarity)
-		priv->conf_polarity = PWM_DUTY_POSTIVE | PWM_INACTIVE_POSTIVE;
+		priv->conf_polarity = PWM_DUTY_POSTIVE | PWM_INACTIVE_NEGATIVE;
 
 	return 0;
 }
diff --git a/drivers/video/rockchip/rk_edp.c b/drivers/video/rockchip/rk_edp.c
index 0be60e169e..0ddf5e02d6 100644
--- a/drivers/video/rockchip/rk_edp.c
+++ b/drivers/video/rockchip/rk_edp.c
@@ -8,20 +8,21 @@
 #include <clk.h>
 #include <display.h>
 #include <dm.h>
+#include <dm/device_compat.h>
 #include <edid.h>
 #include <log.h>
 #include <malloc.h>
 #include <panel.h>
 #include <regmap.h>
+#include <reset.h>
 #include <syscon.h>
 #include <asm/gpio.h>
 #include <asm/io.h>
 #include <asm/arch-rockchip/clock.h>
+#include <asm/arch-rockchip/hardware.h>
 #include <asm/arch-rockchip/edp_rk3288.h>
 #include <asm/arch-rockchip/grf_rk3288.h>
-#include <asm/arch-rockchip/hardware.h>
-#include <dt-bindings/clock/rk3288-cru.h>
-#include <linux/delay.h>
+#include <asm/arch-rockchip/grf_rk3399.h>
 
 #define MAX_CR_LOOP 5
 #define MAX_EQ_LOOP 5
@@ -37,18 +38,42 @@ static const char * const pre_emph_names[] = {
 #define DP_VOLTAGE_MAX         DP_TRAIN_VOLTAGE_SWING_1200
 #define DP_PRE_EMPHASIS_MAX    DP_TRAIN_PRE_EMPHASIS_9_5
 
+#define RK3288_GRF_SOC_CON6	0x025c
+#define RK3288_GRF_SOC_CON12	0x0274
+#define RK3399_GRF_SOC_CON20	0x6250
+#define RK3399_GRF_SOC_CON25	0x6264
+
+enum rockchip_dp_types {
+	RK3288_DP = 0,
+	RK3399_EDP
+};
+
+struct rockchip_dp_data {
+	unsigned long reg_vop_big_little;
+	unsigned long reg_vop_big_little_sel;
+	unsigned long reg_ref_clk_sel;
+	unsigned long ref_clk_sel_bit;
+	enum rockchip_dp_types chip_type;
+};
+
 struct rk_edp_priv {
 	struct rk3288_edp *regs;
-	struct rk3288_grf *grf;
+	void *grf;
 	struct udevice *panel;
 	struct link_train link_train;
 	u8 train_set[4];
 };
 
-static void rk_edp_init_refclk(struct rk3288_edp *regs)
+static void rk_edp_init_refclk(struct rk3288_edp *regs, enum rockchip_dp_types chip_type)
 {
 	writel(SEL_24M, &regs->analog_ctl_2);
-	writel(REF_CLK_24M, &regs->pll_reg_1);
+	u32 reg;
+
+	reg = REF_CLK_24M;
+	if (chip_type == RK3288_DP)
+		reg ^= REF_CLK_MASK;
+	writel(reg, &regs->pll_reg_1);
+
 
 	writel(LDO_OUTPUT_V_SEL_145 | KVCO_DEFALUT | CHG_PUMP_CUR_SEL_5US |
 	       V2L_CUR_SEL_1MA, &regs->pll_reg_2);
@@ -1029,6 +1054,9 @@ static int rk_edp_probe(struct udevice *dev)
 	struct display_plat *uc_plat = dev_get_uclass_plat(dev);
 	struct rk_edp_priv *priv = dev_get_priv(dev);
 	struct rk3288_edp *regs = priv->regs;
+	struct rockchip_dp_data *edp_data = (struct rockchip_dp_data *)dev_get_driver_data(dev);
+	struct reset_ctl dp_rst;
+
 	struct clk clk;
 	int ret;
 
@@ -1040,19 +1068,39 @@ static int rk_edp_probe(struct udevice *dev)
 		return ret;
 	}
 
-	int vop_id = uc_plat->source_id;
-	debug("%s, uc_plat=%p, vop_id=%u\n", __func__, uc_plat, vop_id);
+	ret = reset_get_by_name(dev, "dp", &dp_rst);
+	if (ret) {
+		dev_err(dev, "failed to get dp reset (ret=%d)\n", ret);
+		return ret;
+	}
 
-	ret = clk_get_by_index(dev, 1, &clk);
-	if (ret >= 0) {
-		ret = clk_set_rate(&clk, 0);
-		clk_free(&clk);
+	ret = reset_assert(&dp_rst);
+	if (ret) {
+		dev_err(dev, "failed to assert dp reset (ret=%d)\n", ret);
+		return ret;
 	}
+	udelay(20);
+
+	ret = reset_deassert(&dp_rst);
 	if (ret) {
-		debug("%s: Failed to set EDP clock: ret=%d\n", __func__, ret);
+		dev_err(dev, "failed to deassert dp reset (ret=%d)\n", ret);
 		return ret;
 	}
 
+	int vop_id = uc_plat->source_id;
+	debug("%s, uc_plat=%p, vop_id=%u\n", __func__, uc_plat, vop_id);
+
+	if (edp_data->chip_type == RK3288_DP) {
+		ret = clk_get_by_index(dev, 1, &clk);
+		if (ret >= 0) {
+			ret = clk_set_rate(&clk, 0);
+			clk_free(&clk);
+		}
+		if (ret) {
+			debug("%s: Failed to set EDP clock: ret=%d\n", __func__, ret);
+			return ret;
+		}
+	}
 	ret = clk_get_by_index(uc_plat->src_dev, 0, &clk);
 	if (ret >= 0) {
 		ret = clk_set_rate(&clk, 192000000);
@@ -1065,15 +1113,17 @@ static int rk_edp_probe(struct udevice *dev)
 	}
 
 	/* grf_edp_ref_clk_sel: from internal 24MHz or 27MHz clock */
-	rk_setreg(&priv->grf->soc_con12, 1 << 4);
+	rk_setreg(priv->grf + edp_data->reg_ref_clk_sel,
+		  edp_data->ref_clk_sel_bit);
 
 	/* select epd signal from vop0 or vop1 */
-	rk_clrsetreg(&priv->grf->soc_con6, (1 << 5),
-	    (vop_id == 1) ? (1 << 5) : (0 << 5));
+	rk_clrsetreg(priv->grf + edp_data->reg_vop_big_little,
+		     edp_data->reg_vop_big_little_sel,
+		     (vop_id == 1) ? edp_data->reg_vop_big_little_sel : 0);
 
 	rockchip_edp_wait_hpd(priv);
 
-	rk_edp_init_refclk(regs);
+	rk_edp_init_refclk(regs, edp_data->chip_type);
 	rk_edp_init_interrupt(regs);
 	rk_edp_enable_sw_function(regs);
 	ret = rk_edp_init_analog_func(regs);
@@ -1089,8 +1139,25 @@ static const struct dm_display_ops dp_rockchip_ops = {
 	.enable = rk_edp_enable,
 };
 
+static const struct rockchip_dp_data rk3399_edp = {
+	.reg_vop_big_little = RK3399_GRF_SOC_CON20,
+	.reg_vop_big_little_sel = BIT(5),
+	.reg_ref_clk_sel = RK3399_GRF_SOC_CON25,
+	.ref_clk_sel_bit = BIT(11),
+	.chip_type = RK3399_EDP,
+};
+
+static const struct rockchip_dp_data rk3288_dp = {
+	.reg_vop_big_little = RK3288_GRF_SOC_CON6,
+	.reg_vop_big_little_sel = BIT(5),
+	.reg_ref_clk_sel = RK3288_GRF_SOC_CON12,
+	.ref_clk_sel_bit = BIT(4),
+	.chip_type = RK3288_DP,
+};
+
 static const struct udevice_id rockchip_dp_ids[] = {
-	{ .compatible = "rockchip,rk3288-edp" },
+	{ .compatible = "rockchip,rk3288-edp", .data = (ulong)&rk3288_dp },
+	{ .compatible = "rockchip,rk3399-edp", .data = (ulong)&rk3399_edp },
 	{ }
 };
 
diff --git a/drivers/video/rockchip/rk_vop.c b/drivers/video/rockchip/rk_vop.c
index fcb393b906..0fabbf7e30 100644
--- a/drivers/video/rockchip/rk_vop.c
+++ b/drivers/video/rockchip/rk_vop.c
@@ -8,9 +8,11 @@
 #include <clk.h>
 #include <display.h>
 #include <dm.h>
+#include <dm/device_compat.h>
 #include <edid.h>
 #include <log.h>
 #include <regmap.h>
+#include <reset.h>
 #include <syscon.h>
 #include <video.h>
 #include <asm/gpio.h>
@@ -20,6 +22,8 @@
 #include <asm/arch-rockchip/vop_rk3288.h>
 #include <dm/device-internal.h>
 #include <dm/uclass-internal.h>
+#include <efi.h>
+#include <efi_loader.h>
 #include <linux/bitops.h>
 #include <linux/err.h>
 #include <power/regulator.h>
@@ -34,14 +38,16 @@ enum vop_pol {
 	DCLK_INVERT    = 3
 };
 
-static void rkvop_enable(struct rk3288_vop *regs, ulong fbbase,
+static void rkvop_enable(struct udevice *dev, struct rk3288_vop *regs, ulong fbbase,
 			 int fb_bits_per_pixel,
-			 const struct display_timing *edid)
+			 const struct display_timing *edid,
+			 struct reset_ctl *dclk_rst)
 {
 	u32 lb_mode;
 	u32 rgb_mode;
 	u32 hactive = edid->hactive.typ;
 	u32 vactive = edid->vactive.typ;
+	int ret;
 
 	writel(V_ACT_WIDTH(hactive - 1) | V_ACT_HEIGHT(vactive - 1),
 	       &regs->win0_act_info);
@@ -89,6 +95,18 @@ static void rkvop_enable(struct rk3288_vop *regs, ulong fbbase,
 
 	writel(fbbase, &regs->win0_yrgb_mst);
 	writel(0x01, &regs->reg_cfg_done); /* enable reg config */
+
+	ret = reset_assert(dclk_rst);
+	if (ret) {
+		dev_warn(dev, "failed to assert dclk reset (ret=%d)\n", ret);
+		return;
+	}
+	udelay(20);
+
+	ret = reset_deassert(dclk_rst);
+	if (ret)
+		dev_warn(dev, "failed to deassert dclk reset (ret=%d)\n", ret);
+
 }
 
 static void rkvop_set_pin_polarity(struct udevice *dev,
@@ -235,12 +253,12 @@ static int rk_display_init(struct udevice *dev, ulong fbbase, ofnode ep_node)
 	struct clk clk;
 	enum video_log2_bpp l2bpp;
 	ofnode remote;
+	const char *compat;
+	struct reset_ctl dclk_rst;
 
-	debug("%s(%s, %lu, %s)\n", __func__,
+	debug("%s(%s, %lx, %s)\n", __func__,
 	      dev_read_name(dev), fbbase, ofnode_get_name(ep_node));
 
-	vop_id = ofnode_read_s32_default(ep_node, "reg", -1);
-	debug("vop_id=%d\n", vop_id);
 	ret = ofnode_read_u32(ep_node, "remote-endpoint", &remote_phandle);
 	if (ret)
 		return ret;
@@ -282,6 +300,28 @@ static int rk_display_init(struct udevice *dev, ulong fbbase, ofnode ep_node)
 		if (disp)
 			break;
 	};
+	compat = ofnode_get_property(remote, "compatible", NULL);
+	if (!compat) {
+		debug("%s(%s): Failed to find compatible property\n",
+		      __func__, dev_read_name(dev));
+		return -EINVAL;
+	}
+	if (strstr(compat, "edp")) {
+		vop_id = VOP_MODE_EDP;
+	} else if (strstr(compat, "mipi")) {
+		vop_id = VOP_MODE_MIPI;
+	} else if (strstr(compat, "hdmi")) {
+		vop_id = VOP_MODE_HDMI;
+	} else if (strstr(compat, "cdn-dp")) {
+		vop_id = VOP_MODE_DP;
+	} else if (strstr(compat, "lvds")) {
+		vop_id = VOP_MODE_LVDS;
+	} else {
+		debug("%s(%s): Failed to find vop mode for %s\n",
+		      __func__, dev_read_name(dev), compat);
+		return -EINVAL;
+	}
+	debug("vop_id=%d\n", vop_id);
 
 	disp_uc_plat = dev_get_uclass_plat(disp);
 	debug("Found device '%s', disp_uc_priv=%p\n", disp->name, disp_uc_plat);
@@ -331,7 +371,14 @@ static int rk_display_init(struct udevice *dev, ulong fbbase, ofnode ep_node)
 	}
 
 	rkvop_mode_set(dev, &timing, vop_id);
-	rkvop_enable(regs, fbbase, 1 << l2bpp, &timing);
+
+	ret = reset_get_by_name(dev, "dclk", &dclk_rst);
+	if (ret) {
+		dev_err(dev, "failed to get dclk reset (ret=%d)\n", ret);
+		return ret;
+	}
+
+	rkvop_enable(dev, regs, fbbase, 1 << l2bpp, &timing, &dclk_rst);
 
 	ret = display_enable(disp, 1 << l2bpp, &timing);
 	if (ret)
@@ -368,11 +415,38 @@ int rk_vop_probe(struct udevice *dev)
 	struct rk_vop_priv *priv = dev_get_priv(dev);
 	int ret = 0;
 	ofnode port, node;
+	struct reset_ctl ahb_rst;
 
 	/* Before relocation we don't need to do anything */
 	if (!(gd->flags & GD_FLG_RELOC))
 		return 0;
 
+	ret = reset_get_by_name(dev, "ahb", &ahb_rst);
+	if (ret) {
+		dev_err(dev, "failed to get ahb reset (ret=%d)\n", ret);
+		return ret;
+	}
+
+	ret = reset_assert(&ahb_rst);
+	if (ret) {
+		dev_err(dev, "failed to assert ahb reset (ret=%d)\n", ret);
+	return ret;
+	}
+	udelay(20);
+
+	ret = reset_deassert(&ahb_rst);
+	if (ret) {
+		dev_err(dev, "failed to deassert ahb reset (ret=%d)\n", ret);
+		return ret;
+	}
+
+	plat->base = gd->bd->bi_dram[0].start + gd->bd->bi_dram[0].size - plat->size;
+
+#if defined(CONFIG_EFI_LOADER)
+	debug("Adding to EFI map %d @ %lx\n", plat->size, plat->base);
+	efi_add_memory_map(plat->base, plat->size, EFI_RESERVED_MEMORY_TYPE);
+#endif
+
 	priv->regs = (struct rk3288_vop *)dev_read_addr(dev);
 
 	/*
-- 
2.29.2

