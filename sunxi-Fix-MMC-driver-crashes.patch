From patchwork Wed Jun 27 00:42:52 2018
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
Subject: [U-Boot, 1/2] arm: timer: factor out FSL arch timer erratum workaround
X-Patchwork-Submitter: Andre Przywara <andre.przywara@arm.com>
X-Patchwork-Id: 935206
X-Patchwork-Delegate: jagannadh.teki@gmail.com
Message-Id: <20180627004253.4094-2-andre.przywara@arm.com>
To: Tom Rini <trini@konsulko.com>, Simon Glass <sjg@chromium.org>,
 Jagan Teki <jagan@openedev.com>, Maxime Ripard <maxime.ripard@bootlin.com>
Cc: Alex Graf <agraf@suse.de>, u-boot@lists.denx.de,
 linux-sunxi@googlegroups.com, Guillaume Gardet <guillaume.gardet@free.fr>
Date: Wed, 27 Jun 2018 01:42:52 +0100
From: Andre Przywara <andre.przywara@arm.com>
List-Id: U-Boot discussion <u-boot.lists.denx.de>

At the moment we have the workaround for the Freescale arch timer
erratum A-008585 merged into the generic timer_read_counter() routine.
Split those two up, so that we can add other errata workaround more
easily. Also add an explaining comment on the way.

Signed-off-by: Andre Przywara <andre.przywara@arm.com>
Tested-by: Jagan Teki <jagan@amarulasolutions.com>
---
 arch/arm/cpu/armv8/generic_timer.c | 31 +++++++++++++++++++++++++------
 1 file changed, 25 insertions(+), 6 deletions(-)

diff --git a/arch/arm/cpu/armv8/generic_timer.c b/arch/arm/cpu/armv8/generic_timer.c
index bf07a706a0..3d04fde650 100644
--- a/arch/arm/cpu/armv8/generic_timer.c
+++ b/arch/arm/cpu/armv8/generic_timer.c
@@ -20,27 +20,46 @@ unsigned long get_tbclk(void)
 	return cntfrq;
 }
 
+#ifdef CONFIG_SYS_FSL_ERRATUM_A008585
 /*
- * Generic timer implementation of timer_read_counter()
+ * FSL erratum A-008585 says that the ARM generic timer counter "has the
+ * potential to contain an erroneous value for a small number of core
+ * clock cycles every time the timer value changes".
+ * This sometimes leads to a consecutive counter read returning a lower
+ * value than the previous one, thus reporting the time to go backwards.
+ * The workaround is to read the counter twice and only return when the value
+ * was the same in both reads.
+ * Assumes that the CPU runs in much higher frequency than the timer.
  */
 unsigned long timer_read_counter(void)
 {
 	unsigned long cntpct;
-#ifdef CONFIG_SYS_FSL_ERRATUM_A008585
-	/* This erratum number needs to be confirmed to match ARM document */
 	unsigned long temp;
-#endif
+
 	isb();
 	asm volatile("mrs %0, cntpct_el0" : "=r" (cntpct));
-#ifdef CONFIG_SYS_FSL_ERRATUM_A008585
 	asm volatile("mrs %0, cntpct_el0" : "=r" (temp));
 	while (temp != cntpct) {
 		asm volatile("mrs %0, cntpct_el0" : "=r" (cntpct));
 		asm volatile("mrs %0, cntpct_el0" : "=r" (temp));
 	}
-#endif
+
 	return cntpct;
 }
+#else
+/*
+ * timer_read_counter() using the Arm Generic Timer (aka arch timer).
+ */
+unsigned long timer_read_counter(void)
+{
+	unsigned long cntpct;
+
+	isb();
+	asm volatile("mrs %0, cntpct_el0" : "=r" (cntpct));
+
+	return cntpct;
+}
+#endif
 
 uint64_t get_ticks(void)
 {

From patchwork Wed Jun 27 00:42:53 2018
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
Subject: [U-Boot,
 2/2] arm: timer: sunxi: add Allwinner timer erratum workaround
X-Patchwork-Submitter: Andre Przywara <andre.przywara@arm.com>
X-Patchwork-Id: 935207
X-Patchwork-Delegate: jagannadh.teki@gmail.com
Message-Id: <20180627004253.4094-3-andre.przywara@arm.com>
To: Tom Rini <trini@konsulko.com>, Simon Glass <sjg@chromium.org>,
 Jagan Teki <jagan@openedev.com>, Maxime Ripard <maxime.ripard@bootlin.com>
Cc: Alex Graf <agraf@suse.de>, u-boot@lists.denx.de,
 linux-sunxi@googlegroups.com, Guillaume Gardet <guillaume.gardet@free.fr>
Date: Wed, 27 Jun 2018 01:42:53 +0100
From: Andre Przywara <andre.przywara@arm.com>
List-Id: U-Boot discussion <u-boot.lists.denx.de>

The Allwinner A64 SoCs suffers from an arch timer implementation erratum,
where sometimes the lower 11 bits of the counter value erroneously
become all 0's or all 1's [1]. This leads to sudden jumps, both forwards and
backwards, with the latter one often showing weird behaviour.
Port the workaround proposed for Linux to U-Boot and activate it for all
A64 boards.
This fixes crashes when accessing MMC devices (SD cards), caused by a
recent change to actually use the counter value for timeout checks.

Fixes: 5ff8e54888e4d26a352453564f7f599d29696dc9 ("sunxi: improve throughput
in the sunxi_mmc driver")

[1] http://lists.infradead.org/pipermail/linux-arm-kernel/2018-May/576886.html

Signed-off-by: Andre Przywara <andre.przywara@arm.com>
Reviewed-by: Philipp Tomsich <philipp.tomsich@theobroma-systems.com>
Tested-by: Jagan Teki <jagan@amarulasolutions.com>
---
 arch/arm/cpu/armv8/generic_timer.c | 24 ++++++++++++++++++++++++
 arch/arm/mach-sunxi/Kconfig        |  4 ++++
 2 files changed, 28 insertions(+)

diff --git a/arch/arm/cpu/armv8/generic_timer.c b/arch/arm/cpu/armv8/generic_timer.c
index 3d04fde650..c1706dcec1 100644
--- a/arch/arm/cpu/armv8/generic_timer.c
+++ b/arch/arm/cpu/armv8/generic_timer.c
@@ -46,6 +46,30 @@ unsigned long timer_read_counter(void)
 
 	return cntpct;
 }
+#elif CONFIG_SUNXI_A64_TIMER_ERRATUM
+/*
+ * This erratum sometimes flips the lower 11 bits of the counter value
+ * to all 0's or all 1's, leading to jumps forwards or backwards.
+ * Backwards jumps might be interpreted all roll-overs and be treated as
+ * huge jumps forward.
+ * The workaround is to check whether the lower 11 bits of the counter are
+ * all 0 or all 1, then discard this value and read again.
+ * This occasionally discards valid values, but will catch all erroneous
+ * reads and fixes the problem reliably. Also this mostly requires only a
+ * single read, so does not have any significant overhead.
+ * The algorithm was conceived by Samuel Holland.
+ */
+unsigned long timer_read_counter(void)
+{
+	unsigned long cntpct;
+
+	isb();
+	do {
+		asm volatile("mrs %0, cntpct_el0" : "=r" (cntpct));
+	} while (((cntpct + 1) & GENMASK(10, 0)) <= 1);
+
+	return cntpct;
+}
 #else
 /*
  * timer_read_counter() using the Arm Generic Timer (aka arch timer).
diff --git a/arch/arm/mach-sunxi/Kconfig b/arch/arm/mach-sunxi/Kconfig
index a3f7723028..3624a03947 100644
--- a/arch/arm/mach-sunxi/Kconfig
+++ b/arch/arm/mach-sunxi/Kconfig
@@ -84,6 +84,9 @@ config SUNXI_HIGH_SRAM
 	Chips using the latter setup are supposed to select this option to
 	adjust the addresses accordingly.
 
+config SUNXI_A64_TIMER_ERRATUM
+	bool
+
 # Note only one of these may be selected at a time! But hidden choices are
 # not supported by Kconfig
 config SUNXI_GEN_SUN4I
@@ -270,6 +273,7 @@ config MACH_SUN50I
 	select SUNXI_DRAM_DW_32BIT
 	select FIT
 	select SPL_LOAD_FIT
+	select SUNXI_A64_TIMER_ERRATUM
 
 config MACH_SUN50I_H5
 	bool "sun50i (Allwinner H5)"
