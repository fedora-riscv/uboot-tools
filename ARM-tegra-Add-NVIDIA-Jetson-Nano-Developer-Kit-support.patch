From patchwork Mon Mar 18 23:24:08 2019
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
Subject: [U-Boot,v2,01/15] ARM: tegra: Use common header for PMU declarations
X-Patchwork-Submitter: Thierry Reding <thierry.reding@gmail.com>
X-Patchwork-Id: 1058145
X-Patchwork-Delegate: twarren@nvidia.com
Message-Id: <20190318232422.24404-2-thierry.reding@gmail.com>
To: Tom Warren <twarren@nvidia.com>
Cc: u-boot@lists.denx.de, Stephen Warren <swarren@nvidia.com>
Date: Tue, 19 Mar 2019 00:24:08 +0100
From: Thierry Reding <thierry.reding@gmail.com>
List-Id: U-Boot discussion <u-boot.lists.denx.de>

From: Thierry Reding <treding@nvidia.com>

There's no need to replicate the pmu.h header file for every Tegra SoC
generation. Use a single header that is shared across generations.

Signed-off-by: Thierry Reding <treding@nvidia.com>
---
 .../include/asm/{arch-tegra20 => arch-tegra}/pmu.h  |  6 +++---
 arch/arm/include/asm/arch-tegra114/pmu.h            | 12 ------------
 arch/arm/include/asm/arch-tegra124/pmu.h            | 13 -------------
 arch/arm/include/asm/arch-tegra210/pmu.h            | 13 -------------
 arch/arm/include/asm/arch-tegra30/pmu.h             | 12 ------------
 arch/arm/mach-tegra/board2.c                        |  2 +-
 arch/arm/mach-tegra/emc.c                           |  2 +-
 7 files changed, 5 insertions(+), 55 deletions(-)
 rename arch/arm/include/asm/{arch-tegra20 => arch-tegra}/pmu.h (73%)
 delete mode 100644 arch/arm/include/asm/arch-tegra114/pmu.h
 delete mode 100644 arch/arm/include/asm/arch-tegra124/pmu.h
 delete mode 100644 arch/arm/include/asm/arch-tegra210/pmu.h
 delete mode 100644 arch/arm/include/asm/arch-tegra30/pmu.h

diff --git a/arch/arm/include/asm/arch-tegra20/pmu.h b/arch/arm/include/asm/arch-tegra/pmu.h
similarity index 73%
rename from arch/arm/include/asm/arch-tegra20/pmu.h
rename to arch/arm/include/asm/arch-tegra/pmu.h
index 18766dfed2bb..e850875d3166 100644
--- a/arch/arm/include/asm/arch-tegra20/pmu.h
+++ b/arch/arm/include/asm/arch-tegra/pmu.h
@@ -4,10 +4,10 @@
  *  NVIDIA Corporation <www.nvidia.com>
  */
 
-#ifndef _ARCH_PMU_H_
-#define _ARCH_PMU_H_
+#ifndef _TEGRA_PMU_H_
+#define _TEGRA_PMU_H_
 
 /* Set core and CPU voltages to nominal levels */
 int pmu_set_nominal(void);
 
-#endif	/* _ARCH_PMU_H_ */
+#endif	/* _TEGRA_PMU_H_ */
diff --git a/arch/arm/include/asm/arch-tegra114/pmu.h b/arch/arm/include/asm/arch-tegra114/pmu.h
deleted file mode 100644
index 1e571ee7b317..000000000000
--- a/arch/arm/include/asm/arch-tegra114/pmu.h
+++ /dev/null
@@ -1,12 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * Copyright (c) 2010-2013, NVIDIA CORPORATION.  All rights reserved.
- */
-
-#ifndef _TEGRA114_PMU_H_
-#define _TEGRA114_PMU_H_
-
-/* Set core and CPU voltages to nominal levels */
-int pmu_set_nominal(void);
-
-#endif	/* _TEGRA114_PMU_H_ */
diff --git a/arch/arm/include/asm/arch-tegra124/pmu.h b/arch/arm/include/asm/arch-tegra124/pmu.h
deleted file mode 100644
index c38393edefda..000000000000
--- a/arch/arm/include/asm/arch-tegra124/pmu.h
+++ /dev/null
@@ -1,13 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0+ */
-/*
- * (C) Copyright 2010-2013
- * NVIDIA Corporation <www.nvidia.com>
- */
-
-#ifndef _TEGRA124_PMU_H_
-#define _TEGRA124_PMU_H_
-
-/* Set core and CPU voltages to nominal levels */
-int pmu_set_nominal(void);
-
-#endif	/* _TEGRA124_PMU_H_ */
diff --git a/arch/arm/include/asm/arch-tegra210/pmu.h b/arch/arm/include/asm/arch-tegra210/pmu.h
deleted file mode 100644
index 6ea36aa41876..000000000000
--- a/arch/arm/include/asm/arch-tegra210/pmu.h
+++ /dev/null
@@ -1,13 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0+ */
-/*
- * (C) Copyright 2010-2015
- * NVIDIA Corporation <www.nvidia.com>
- */
-
-#ifndef _TEGRA210_PMU_H_
-#define _TEGRA210_PMU_H_
-
-/* Set core and CPU voltages to nominal levels */
-int pmu_set_nominal(void);
-
-#endif	/* _TEGRA210_PMU_H_ */
diff --git a/arch/arm/include/asm/arch-tegra30/pmu.h b/arch/arm/include/asm/arch-tegra30/pmu.h
deleted file mode 100644
index a823f0fbfc61..000000000000
--- a/arch/arm/include/asm/arch-tegra30/pmu.h
+++ /dev/null
@@ -1,12 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * Copyright (c) 2010-2012, NVIDIA CORPORATION.  All rights reserved.
- */
-
-#ifndef _TEGRA30_PMU_H_
-#define _TEGRA30_PMU_H_
-
-/* Set core and CPU voltages to nominal levels */
-int pmu_set_nominal(void);
-
-#endif	/* _TEGRA30_PMU_H_ */
diff --git a/arch/arm/mach-tegra/board2.c b/arch/arm/mach-tegra/board2.c
index 12257a42b51b..b8d5ef0322cb 100644
--- a/arch/arm/mach-tegra/board2.c
+++ b/arch/arm/mach-tegra/board2.c
@@ -15,6 +15,7 @@
 #include <asm/arch-tegra/board.h>
 #include <asm/arch-tegra/clk_rst.h>
 #include <asm/arch-tegra/pmc.h>
+#include <asm/arch-tegra/pmu.h>
 #include <asm/arch-tegra/sys_proto.h>
 #include <asm/arch-tegra/uart.h>
 #include <asm/arch-tegra/warmboot.h>
@@ -24,7 +25,6 @@
 #include <asm/arch/clock.h>
 #include <asm/arch/funcmux.h>
 #include <asm/arch/pinmux.h>
-#include <asm/arch/pmu.h>
 #include <asm/arch/tegra.h>
 #ifdef CONFIG_TEGRA_CLOCK_SCALING
 #include <asm/arch/emc.h>
diff --git a/arch/arm/mach-tegra/emc.c b/arch/arm/mach-tegra/emc.c
index 6697909d9a3e..66628933b653 100644
--- a/arch/arm/mach-tegra/emc.c
+++ b/arch/arm/mach-tegra/emc.c
@@ -8,10 +8,10 @@
 #include <asm/io.h>
 #include <asm/arch/clock.h>
 #include <asm/arch/emc.h>
-#include <asm/arch/pmu.h>
 #include <asm/arch/tegra.h>
 #include <asm/arch-tegra/ap.h>
 #include <asm/arch-tegra/clk_rst.h>
+#include <asm/arch-tegra/pmu.h>
 #include <asm/arch-tegra/sys_proto.h>
 
 DECLARE_GLOBAL_DATA_PTR;

From patchwork Mon Mar 18 23:24:09 2019
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
Subject: [U-Boot,v2,02/15] ARM: tegra: Guard clock code with a Kconfig symbol
X-Patchwork-Submitter: Thierry Reding <thierry.reding@gmail.com>
X-Patchwork-Id: 1058147
X-Patchwork-Delegate: twarren@nvidia.com
Message-Id: <20190318232422.24404-3-thierry.reding@gmail.com>
To: Tom Warren <twarren@nvidia.com>
Cc: u-boot@lists.denx.de, Stephen Warren <swarren@nvidia.com>
Date: Tue, 19 Mar 2019 00:24:09 +0100
From: Thierry Reding <thierry.reding@gmail.com>
List-Id: U-Boot discussion <u-boot.lists.denx.de>

From: Thierry Reding <treding@nvidia.com>

Clock code is not relevant on all Tegra SoC generations, so guard it
with a Kconfig symbol that can be selected by the generations that need
it.

This is in preparation for unifying Tegra186 code with the code used on
older generations.

Signed-off-by: Thierry Reding <treding@nvidia.com>
---
 arch/arm/mach-tegra/Kconfig  |  5 +++++
 arch/arm/mach-tegra/Makefile |  2 +-
 arch/arm/mach-tegra/board.c  |  2 ++
 arch/arm/mach-tegra/board2.c | 12 ++++++++++--
 4 files changed, 18 insertions(+), 3 deletions(-)

diff --git a/arch/arm/mach-tegra/Kconfig b/arch/arm/mach-tegra/Kconfig
index 86b1cd11f752..ee078fec9adc 100644
--- a/arch/arm/mach-tegra/Kconfig
+++ b/arch/arm/mach-tegra/Kconfig
@@ -12,6 +12,9 @@ config SPL_LIBGENERIC_SUPPORT
 config SPL_SERIAL_SUPPORT
 	default y
 
+config TEGRA_CLKRST
+	bool
+
 config TEGRA_IVC
 	bool "Tegra IVC protocol"
 	help
@@ -55,6 +58,7 @@ config TEGRA_ARMV7_COMMON
 	select SPL
 	select SPL_BOARD_INIT if SPL
 	select SUPPORT_SPL
+	select TEGRA_CLKRST
 	select TEGRA_COMMON
 	select TEGRA_GPIO
 	select TEGRA_NO_BPMP
@@ -100,6 +104,7 @@ config TEGRA124
 config TEGRA210
 	bool "Tegra210 family"
 	select TEGRA_ARMV8_COMMON
+	select TEGRA_CLKRST
 	select TEGRA_GPIO
 	select TEGRA_NO_BPMP
 
diff --git a/arch/arm/mach-tegra/Makefile b/arch/arm/mach-tegra/Makefile
index d4b4666fb1e2..0e812818d7a2 100644
--- a/arch/arm/mach-tegra/Makefile
+++ b/arch/arm/mach-tegra/Makefile
@@ -16,7 +16,7 @@ endif
 obj-y += ap.o
 obj-y += board.o board2.o
 obj-y += cache.o
-obj-y += clock.o
+obj-$(CONFIG_TEGRA_CLKRST) += clock.o
 obj-y += pinmux-common.o
 obj-y += powergate.o
 obj-y += xusb-padctl-dummy.o
diff --git a/arch/arm/mach-tegra/board.c b/arch/arm/mach-tegra/board.c
index f8fc042a1dcc..ecd5001de4c5 100644
--- a/arch/arm/mach-tegra/board.c
+++ b/arch/arm/mach-tegra/board.c
@@ -9,7 +9,9 @@
 #include <ns16550.h>
 #include <spl.h>
 #include <asm/io.h>
+#if IS_ENABLED(CONFIG_TEGRA_CLKRST)
 #include <asm/arch/clock.h>
+#endif
 #include <asm/arch/funcmux.h>
 #include <asm/arch/mc.h>
 #include <asm/arch/tegra.h>
diff --git a/arch/arm/mach-tegra/board2.c b/arch/arm/mach-tegra/board2.c
index b8d5ef0322cb..b94077221f77 100644
--- a/arch/arm/mach-tegra/board2.c
+++ b/arch/arm/mach-tegra/board2.c
@@ -22,7 +22,9 @@
 #include <asm/arch-tegra/gpu.h>
 #include <asm/arch-tegra/usb.h>
 #include <asm/arch-tegra/xusb-padctl.h>
+#if IS_ENABLED(CONFIG_TEGRA_CLKRST)
 #include <asm/arch/clock.h>
+#endif
 #include <asm/arch/funcmux.h>
 #include <asm/arch/pinmux.h>
 #include <asm/arch/tegra.h>
@@ -109,8 +111,10 @@ int board_init(void)
 	__maybe_unused int board_id;
 
 	/* Do clocks and UART first so that printf() works */
+#if IS_ENABLED(CONFIG_TEGRA_CLKRST)
 	clock_init();
 	clock_verify();
+#endif
 
 	tegra_gpu_config();
 
@@ -181,8 +185,10 @@ void gpio_early_init(void) __attribute__((weak, alias("__gpio_early_init")));
 
 int board_early_init_f(void)
 {
+#if IS_ENABLED(CONFIG_TEGRA_CLKRST)
 	if (!clock_early_init_done())
 		clock_early_init();
+#endif
 
 #if defined(CONFIG_TEGRA_DISCONNECT_UDC_ON_BOOT)
 #define USBCMD_FS2 (1 << 15)
@@ -193,10 +199,12 @@ int board_early_init_f(void)
 #endif
 
 	/* Do any special system timer/TSC setup */
-#if defined(CONFIG_TEGRA_SUPPORT_NON_SECURE)
+#if IS_ENABLED(CONFIG_TEGRA_CLKRST)
+#  if defined(CONFIG_TEGRA_SUPPORT_NON_SECURE)
 	if (!tegra_cpu_is_non_secure())
-#endif
+#  endif
 		arch_timer_init();
+#endif
 
 	pinmux_init();
 	board_init_uart_f();

From patchwork Mon Mar 18 23:24:10 2019
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
Subject: [U-Boot, v2,
 03/15] ARM: tegra: Guard GP pad control code with a Kconfig symbol
X-Patchwork-Submitter: Thierry Reding <thierry.reding@gmail.com>
X-Patchwork-Id: 1058148
X-Patchwork-Delegate: twarren@nvidia.com
Message-Id: <20190318232422.24404-4-thierry.reding@gmail.com>
To: Tom Warren <twarren@nvidia.com>
Cc: u-boot@lists.denx.de, Stephen Warren <swarren@nvidia.com>
Date: Tue, 19 Mar 2019 00:24:10 +0100
From: Thierry Reding <thierry.reding@gmail.com>
List-Id: U-Boot discussion <u-boot.lists.denx.de>

From: Thierry Reding <treding@nvidia.com>

The GP pad control code is not relevant on all Tegra SoC generations, so
guard it with a Kconfig symbol that can be selected by the generations
that need it.

This is in preparation for unifying Tegra186 code with the code used on
older generations.

Signed-off-by: Thierry Reding <treding@nvidia.com>
---
 arch/arm/mach-tegra/Kconfig  | 5 +++++
 arch/arm/mach-tegra/Makefile | 2 +-
 arch/arm/mach-tegra/cache.c  | 2 ++
 3 files changed, 8 insertions(+), 1 deletion(-)

diff --git a/arch/arm/mach-tegra/Kconfig b/arch/arm/mach-tegra/Kconfig
index ee078fec9adc..265051b18aaf 100644
--- a/arch/arm/mach-tegra/Kconfig
+++ b/arch/arm/mach-tegra/Kconfig
@@ -15,6 +15,9 @@ config SPL_SERIAL_SUPPORT
 config TEGRA_CLKRST
 	bool
 
+config TEGRA_GP_PADCTRL
+	bool
+
 config TEGRA_IVC
 	bool "Tegra IVC protocol"
 	help
@@ -61,6 +64,7 @@ config TEGRA_ARMV7_COMMON
 	select TEGRA_CLKRST
 	select TEGRA_COMMON
 	select TEGRA_GPIO
+	select TEGRA_GP_PADCTRL
 	select TEGRA_NO_BPMP
 
 config TEGRA_ARMV8_COMMON
@@ -106,6 +110,7 @@ config TEGRA210
 	select TEGRA_ARMV8_COMMON
 	select TEGRA_CLKRST
 	select TEGRA_GPIO
+	select TEGRA_GP_PADCTRL
 	select TEGRA_NO_BPMP
 
 config TEGRA186
diff --git a/arch/arm/mach-tegra/Makefile b/arch/arm/mach-tegra/Makefile
index 0e812818d7a2..69f802c01b45 100644
--- a/arch/arm/mach-tegra/Makefile
+++ b/arch/arm/mach-tegra/Makefile
@@ -13,7 +13,7 @@ else
 obj-$(CONFIG_CMD_ENTERRCM) += cmd_enterrcm.o
 endif
 
-obj-y += ap.o
+obj-$(CONFIG_TEGRA_GP_PADCTRL) += ap.o
 obj-y += board.o board2.o
 obj-y += cache.o
 obj-$(CONFIG_TEGRA_CLKRST) += clock.o
diff --git a/arch/arm/mach-tegra/cache.c b/arch/arm/mach-tegra/cache.c
index be414e4e4aca..d7063490e222 100644
--- a/arch/arm/mach-tegra/cache.c
+++ b/arch/arm/mach-tegra/cache.c
@@ -8,7 +8,9 @@
 #include <common.h>
 #include <asm/io.h>
 #include <asm/arch-tegra/ap.h>
+#if IS_ENABLED(CONFIG_TEGRA_GP_PADCTRL)
 #include <asm/arch/gp_padctrl.h>
+#endif
 
 #ifndef CONFIG_ARM64
 void config_cache(void)

From patchwork Mon Mar 18 23:24:11 2019
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
Subject: [U-Boot, v2,
 04/15] ARM: tegra: Guard memory controller code with a Kconfig symbol
X-Patchwork-Submitter: Thierry Reding <thierry.reding@gmail.com>
X-Patchwork-Id: 1058146
X-Patchwork-Delegate: twarren@nvidia.com
Message-Id: <20190318232422.24404-5-thierry.reding@gmail.com>
To: Tom Warren <twarren@nvidia.com>
Cc: u-boot@lists.denx.de, Stephen Warren <swarren@nvidia.com>
Date: Tue, 19 Mar 2019 00:24:11 +0100
From: Thierry Reding <thierry.reding@gmail.com>
List-Id: U-Boot discussion <u-boot.lists.denx.de>

From: Thierry Reding <treding@nvidia.com>

Memory controller code is not relevant on all Tegra SoC generations, so
guard it with a Kconfig symbol that can be selected by the generations
that need it.

This is in preparation for unifying Tegra186 code with the code used on
older generations.

Signed-off-by: Thierry Reding <treding@nvidia.com>
---
 arch/arm/mach-tegra/Kconfig | 5 +++++
 arch/arm/mach-tegra/board.c | 7 +++++++
 2 files changed, 12 insertions(+)

diff --git a/arch/arm/mach-tegra/Kconfig b/arch/arm/mach-tegra/Kconfig
index 265051b18aaf..5763c4ae3cd1 100644
--- a/arch/arm/mach-tegra/Kconfig
+++ b/arch/arm/mach-tegra/Kconfig
@@ -26,6 +26,9 @@ config TEGRA_IVC
 	  U-Boot, it is typically used for communication between the main CPU
 	  and various auxiliary processors.
 
+config TEGRA_MC
+	bool
+
 config TEGRA_COMMON
 	bool "Tegra common options"
 	select BINMAN
@@ -65,6 +68,7 @@ config TEGRA_ARMV7_COMMON
 	select TEGRA_COMMON
 	select TEGRA_GPIO
 	select TEGRA_GP_PADCTRL
+	select TEGRA_MC
 	select TEGRA_NO_BPMP
 
 config TEGRA_ARMV8_COMMON
@@ -111,6 +115,7 @@ config TEGRA210
 	select TEGRA_CLKRST
 	select TEGRA_GPIO
 	select TEGRA_GP_PADCTRL
+	select TEGRA_MC
 	select TEGRA_NO_BPMP
 
 config TEGRA186
diff --git a/arch/arm/mach-tegra/board.c b/arch/arm/mach-tegra/board.c
index ecd5001de4c5..7ef5a67edd1f 100644
--- a/arch/arm/mach-tegra/board.c
+++ b/arch/arm/mach-tegra/board.c
@@ -13,7 +13,9 @@
 #include <asm/arch/clock.h>
 #endif
 #include <asm/arch/funcmux.h>
+#if IS_ENABLED(CONFIG_TEGRA_MC)
 #include <asm/arch/mc.h>
+#endif
 #include <asm/arch/tegra.h>
 #include <asm/arch-tegra/ap.h>
 #include <asm/arch-tegra/board.h>
@@ -68,6 +70,7 @@ bool tegra_cpu_is_non_secure(void)
 }
 #endif
 
+#if IS_ENABLED(CONFIG_TEGRA_MC)
 /* Read the RAM size directly from the memory controller */
 static phys_size_t query_sdram_size(void)
 {
@@ -117,11 +120,15 @@ static phys_size_t query_sdram_size(void)
 
 	return size_bytes;
 }
+#endif
 
 int dram_init(void)
 {
+#if IS_ENABLED(CONFIG_TEGRA_MC)
 	/* We do not initialise DRAM here. We just query the size */
 	gd->ram_size = query_sdram_size();
+#endif
+
 	return 0;
 }
 

From patchwork Mon Mar 18 23:24:12 2019
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
Subject: [U-Boot, v2,
 05/15] ARM: tegra: Guard pin controller code with a Kconfig symbol
X-Patchwork-Submitter: Thierry Reding <thierry.reding@gmail.com>
X-Patchwork-Id: 1058156
X-Patchwork-Delegate: twarren@nvidia.com
Message-Id: <20190318232422.24404-6-thierry.reding@gmail.com>
To: Tom Warren <twarren@nvidia.com>
Cc: u-boot@lists.denx.de, Stephen Warren <swarren@nvidia.com>
Date: Tue, 19 Mar 2019 00:24:12 +0100
From: Thierry Reding <thierry.reding@gmail.com>
List-Id: U-Boot discussion <u-boot.lists.denx.de>

From: Thierry Reding <treding@nvidia.com>

Pin controller code is not relevant on all Tegra SoC generations, so
guard it with a Kconfig symbol that can be selected by the generations
that need it.

This is in preparation for unifying Tegra186 code with the code used on
older generations.

Signed-off-by: Thierry Reding <treding@nvidia.com>
---
 arch/arm/mach-tegra/Kconfig  | 5 +++++
 arch/arm/mach-tegra/Makefile | 2 +-
 arch/arm/mach-tegra/board.c  | 6 ++++++
 arch/arm/mach-tegra/board2.c | 2 ++
 4 files changed, 14 insertions(+), 1 deletion(-)

diff --git a/arch/arm/mach-tegra/Kconfig b/arch/arm/mach-tegra/Kconfig
index 5763c4ae3cd1..be20ac2e804e 100644
--- a/arch/arm/mach-tegra/Kconfig
+++ b/arch/arm/mach-tegra/Kconfig
@@ -29,6 +29,9 @@ config TEGRA_IVC
 config TEGRA_MC
 	bool
 
+config TEGRA_PINCTRL
+	bool
+
 config TEGRA_COMMON
 	bool "Tegra common options"
 	select BINMAN
@@ -70,6 +73,7 @@ config TEGRA_ARMV7_COMMON
 	select TEGRA_GP_PADCTRL
 	select TEGRA_MC
 	select TEGRA_NO_BPMP
+	select TEGRA_PINCTRL
 
 config TEGRA_ARMV8_COMMON
 	bool "Tegra 64-bit common options"
@@ -117,6 +121,7 @@ config TEGRA210
 	select TEGRA_GP_PADCTRL
 	select TEGRA_MC
 	select TEGRA_NO_BPMP
+	select TEGRA_PINCTRL
 
 config TEGRA186
 	bool "Tegra186 family"
diff --git a/arch/arm/mach-tegra/Makefile b/arch/arm/mach-tegra/Makefile
index 69f802c01b45..395e0191a458 100644
--- a/arch/arm/mach-tegra/Makefile
+++ b/arch/arm/mach-tegra/Makefile
@@ -17,7 +17,7 @@ obj-$(CONFIG_TEGRA_GP_PADCTRL) += ap.o
 obj-y += board.o board2.o
 obj-y += cache.o
 obj-$(CONFIG_TEGRA_CLKRST) += clock.o
-obj-y += pinmux-common.o
+obj-$(CONFIG_TEGRA_PINCTRL) += pinmux-common.o
 obj-y += powergate.o
 obj-y += xusb-padctl-dummy.o
 endif
diff --git a/arch/arm/mach-tegra/board.c b/arch/arm/mach-tegra/board.c
index 7ef5a67edd1f..b65bdde5a78d 100644
--- a/arch/arm/mach-tegra/board.c
+++ b/arch/arm/mach-tegra/board.c
@@ -12,7 +12,9 @@
 #if IS_ENABLED(CONFIG_TEGRA_CLKRST)
 #include <asm/arch/clock.h>
 #endif
+#if IS_ENABLED(CONFIG_TEGRA_PINCTRL)
 #include <asm/arch/funcmux.h>
+#endif
 #if IS_ENABLED(CONFIG_TEGRA_MC)
 #include <asm/arch/mc.h>
 #endif
@@ -132,6 +134,7 @@ int dram_init(void)
 	return 0;
 }
 
+#if IS_ENABLED(CONFIG_TEGRA_PINCTRL)
 static int uart_configs[] = {
 #if defined(CONFIG_TEGRA20)
  #if defined(CONFIG_TEGRA_UARTA_UAA_UAB)
@@ -199,9 +202,11 @@ static void setup_uarts(int uart_ids)
 		}
 	}
 }
+#endif
 
 void board_init_uart_f(void)
 {
+#if IS_ENABLED(CONFIG_TEGRA_PINCTRL)
 	int uart_ids = 0;	/* bit mask of which UART ids to enable */
 
 #ifdef CONFIG_TEGRA_ENABLE_UARTA
@@ -220,6 +225,7 @@ void board_init_uart_f(void)
 	uart_ids |= UARTE;
 #endif
 	setup_uarts(uart_ids);
+#endif
 }
 
 #if !CONFIG_IS_ENABLED(OF_CONTROL)
diff --git a/arch/arm/mach-tegra/board2.c b/arch/arm/mach-tegra/board2.c
index b94077221f77..ce1c9346959d 100644
--- a/arch/arm/mach-tegra/board2.c
+++ b/arch/arm/mach-tegra/board2.c
@@ -25,8 +25,10 @@
 #if IS_ENABLED(CONFIG_TEGRA_CLKRST)
 #include <asm/arch/clock.h>
 #endif
+#if IS_ENABLED(CONFIG_TEGRA_PINCTRL)
 #include <asm/arch/funcmux.h>
 #include <asm/arch/pinmux.h>
+#endif
 #include <asm/arch/tegra.h>
 #ifdef CONFIG_TEGRA_CLOCK_SCALING
 #include <asm/arch/emc.h>

From patchwork Mon Mar 18 23:24:13 2019
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
Subject: [U-Boot, v2,
 06/15] ARM: tegra: Guard powergate code with a Kconfig symbol
X-Patchwork-Submitter: Thierry Reding <thierry.reding@gmail.com>
X-Patchwork-Id: 1058150
X-Patchwork-Delegate: twarren@nvidia.com
Message-Id: <20190318232422.24404-7-thierry.reding@gmail.com>
To: Tom Warren <twarren@nvidia.com>
Cc: u-boot@lists.denx.de, Stephen Warren <swarren@nvidia.com>
Date: Tue, 19 Mar 2019 00:24:13 +0100
From: Thierry Reding <thierry.reding@gmail.com>
List-Id: U-Boot discussion <u-boot.lists.denx.de>

From: Thierry Reding <treding@nvidia.com>

Powergate code is not relevant on all Tegra SoC generations, so guard it
with a Kconfig symbol that can be selected by the generations that need
it.

This is in preparation for unifying Tegra186 code with the code used on
older generations.

Signed-off-by: Thierry Reding <treding@nvidia.com>
---
 arch/arm/mach-tegra/Kconfig  | 5 +++++
 arch/arm/mach-tegra/Makefile | 2 +-
 2 files changed, 6 insertions(+), 1 deletion(-)

diff --git a/arch/arm/mach-tegra/Kconfig b/arch/arm/mach-tegra/Kconfig
index be20ac2e804e..db9198348d3f 100644
--- a/arch/arm/mach-tegra/Kconfig
+++ b/arch/arm/mach-tegra/Kconfig
@@ -32,6 +32,9 @@ config TEGRA_MC
 config TEGRA_PINCTRL
 	bool
 
+config TEGRA_PMC
+	bool
+
 config TEGRA_COMMON
 	bool "Tegra common options"
 	select BINMAN
@@ -74,6 +77,7 @@ config TEGRA_ARMV7_COMMON
 	select TEGRA_MC
 	select TEGRA_NO_BPMP
 	select TEGRA_PINCTRL
+	select TEGRA_PMC
 
 config TEGRA_ARMV8_COMMON
 	bool "Tegra 64-bit common options"
@@ -122,6 +126,7 @@ config TEGRA210
 	select TEGRA_MC
 	select TEGRA_NO_BPMP
 	select TEGRA_PINCTRL
+	select TEGRA_PMC
 
 config TEGRA186
 	bool "Tegra186 family"
diff --git a/arch/arm/mach-tegra/Makefile b/arch/arm/mach-tegra/Makefile
index 395e0191a458..517be21ee5f5 100644
--- a/arch/arm/mach-tegra/Makefile
+++ b/arch/arm/mach-tegra/Makefile
@@ -18,7 +18,7 @@ obj-y += board.o board2.o
 obj-y += cache.o
 obj-$(CONFIG_TEGRA_CLKRST) += clock.o
 obj-$(CONFIG_TEGRA_PINCTRL) += pinmux-common.o
-obj-y += powergate.o
+obj-$(CONFIG_TEGRA_PMC) += powergate.o
 obj-y += xusb-padctl-dummy.o
 endif
 

From patchwork Mon Mar 18 23:24:14 2019
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
Subject: [U-Boot,v2,07/15] ARM: tegra: Fix save_boot_params() prototype
X-Patchwork-Submitter: Thierry Reding <thierry.reding@gmail.com>
X-Patchwork-Id: 1058149
X-Patchwork-Delegate: twarren@nvidia.com
Message-Id: <20190318232422.24404-8-thierry.reding@gmail.com>
To: Tom Warren <twarren@nvidia.com>
Cc: u-boot@lists.denx.de, Stephen Warren <swarren@nvidia.com>
Date: Tue, 19 Mar 2019 00:24:14 +0100
From: Thierry Reding <thierry.reding@gmail.com>
List-Id: U-Boot discussion <u-boot.lists.denx.de>

From: Thierry Reding <treding@nvidia.com>

The save_boot_params() function takes as its first four arguments the
first four registers. On 32-bit ARM these are r0, r1, r2 and r3, all of
which are 32 bits wide. However, on 64-bit ARM thene registers are x0,
x1, x2 and x3, all of which are 64 bits wide. In order to allow reusing
the save_boot_params() implementation on 64-bit ARM, change it to take
unsigned long parameters rather than the fixed size 32-bit integers.
This ensures that the correct values are passed.

Signed-off-by: Thierry Reding <treding@nvidia.com>
---
 arch/arm/mach-tegra/board.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/arch/arm/mach-tegra/board.c b/arch/arm/mach-tegra/board.c
index b65bdde5a78d..59d2f347485d 100644
--- a/arch/arm/mach-tegra/board.c
+++ b/arch/arm/mach-tegra/board.c
@@ -42,7 +42,8 @@ enum {
 static bool from_spl __attribute__ ((section(".data")));
 
 #ifndef CONFIG_SPL_BUILD
-void save_boot_params(u32 r0, u32 r1, u32 r2, u32 r3)
+void save_boot_params(unsigned long r0, unsigned long r1, unsigned long r2,
+		      unsigned long r3)
 {
 	from_spl = r0 != UBOOT_NOT_LOADED_FROM_SPL;
 	save_boot_params_ret();

From patchwork Mon Mar 18 23:24:15 2019
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
Subject: [U-Boot, v2,
 08/15] ARM: tegra: Allow boards to override boot target devices
X-Patchwork-Submitter: Thierry Reding <thierry.reding@gmail.com>
X-Patchwork-Id: 1058152
X-Patchwork-Delegate: twarren@nvidia.com
Message-Id: <20190318232422.24404-9-thierry.reding@gmail.com>
To: Tom Warren <twarren@nvidia.com>
Cc: u-boot@lists.denx.de, Stephen Warren <swarren@nvidia.com>
Date: Tue, 19 Mar 2019 00:24:15 +0100
From: Thierry Reding <thierry.reding@gmail.com>
List-Id: U-Boot discussion <u-boot.lists.denx.de>

From: Thierry Reding <treding@nvidia.com>

Boards may not support all the boot target devices in the default list
for Tegra devices. Allow a board to override the list and default to the
standard list only if the board hasn't specified one itself.

Signed-off-by: Thierry Reding <treding@nvidia.com>
---
 include/configs/tegra-common-post.h | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/include/configs/tegra-common-post.h b/include/configs/tegra-common-post.h
index e54428ba43e2..9685ee5059ab 100644
--- a/include/configs/tegra-common-post.h
+++ b/include/configs/tegra-common-post.h
@@ -21,12 +21,14 @@
 #define CONFIG_SYS_NONCACHED_MEMORY	(1 << 20)	/* 1 MiB */
 
 #ifndef CONFIG_SPL_BUILD
+#ifndef BOOT_TARGET_DEVICES
 #define BOOT_TARGET_DEVICES(func) \
 	func(MMC, mmc, 1) \
 	func(MMC, mmc, 0) \
 	func(USB, usb, 0) \
 	func(PXE, pxe, na) \
 	func(DHCP, dhcp, na)
+#endif
 #include <config_distro_bootcmd.h>
 #else
 #define BOOTENV

From patchwork Mon Mar 18 23:24:16 2019
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
Subject: [U-Boot,v2,09/15] ARM: tegra: Support TZ-only access to PMC
X-Patchwork-Submitter: Thierry Reding <thierry.reding@gmail.com>
X-Patchwork-Id: 1058153
X-Patchwork-Delegate: twarren@nvidia.com
Message-Id: <20190318232422.24404-10-thierry.reding@gmail.com>
To: Tom Warren <twarren@nvidia.com>
Cc: u-boot@lists.denx.de, Stephen Warren <swarren@nvidia.com>
Date: Tue, 19 Mar 2019 00:24:16 +0100
From: Thierry Reding <thierry.reding@gmail.com>
List-Id: U-Boot discussion <u-boot.lists.denx.de>

From: Thierry Reding <treding@nvidia.com>

Some devices may restrict access to the PMC to TrustZone software only.
Non-TZ software can detect this and use SMC calls to the firmware that
runs in the TrustZone to perform accesses to PMC registers.

Note that this also fixes reset_cpu() and the enterrcm command on
Tegra186 where they were previously trying to access the PMC at a wrong
physical address.

Based on work by Kalyani Chidambaram <kalyanic@nvidia.com> and Tom
Warren <twarren@nvidia.com>.

Signed-off-by: Thierry Reding <treding@nvidia.com>
---
 arch/arm/include/asm/arch-tegra/pmc.h   | 20 +++++-
 arch/arm/include/asm/arch-tegra/tegra.h |  6 ++
 arch/arm/mach-tegra/Kconfig             |  5 ++
 arch/arm/mach-tegra/Makefile            |  4 +-
 arch/arm/mach-tegra/clock.c             | 13 ++--
 arch/arm/mach-tegra/cmd_enterrcm.c      |  6 +-
 arch/arm/mach-tegra/cpu.c               | 20 +++---
 arch/arm/mach-tegra/lowlevel_init.S     | 39 -----------
 arch/arm/mach-tegra/pmc.c               | 92 +++++++++++++++++++++++++
 arch/arm/mach-tegra/powergate.c         | 11 +--
 10 files changed, 151 insertions(+), 65 deletions(-)
 delete mode 100644 arch/arm/mach-tegra/lowlevel_init.S
 create mode 100644 arch/arm/mach-tegra/pmc.c

diff --git a/arch/arm/include/asm/arch-tegra/pmc.h b/arch/arm/include/asm/arch-tegra/pmc.h
index 34bbe75d5fdb..1524bf291164 100644
--- a/arch/arm/include/asm/arch-tegra/pmc.h
+++ b/arch/arm/include/asm/arch-tegra/pmc.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0+ */
 /*
- *  (C) Copyright 2010-2015
+ *  (C) Copyright 2010-2019
  *  NVIDIA Corporation <www.nvidia.com>
  */
 
@@ -388,4 +388,22 @@ struct pmc_ctlr {
 /* APBDEV_PMC_CNTRL2_0 0x440 */
 #define HOLD_CKE_LOW_EN				(1 << 12)
 
+/* PMC read/write functions */
+u32 tegra_pmc_readl(unsigned long offset);
+void tegra_pmc_writel(u32 value, unsigned long offset);
+
+#define PMC_CNTRL		0x0
+#define  PMC_CNTRL_MAIN_RST	BIT(4)
+
+#if IS_ENABLED(CONFIG_TEGRA186)
+#  define PMC_SCRATCH0 0x32000
+#else
+#  define PMC_SCRATCH0 0x00050
+#endif
+
+/* for secure PMC */
+#define TEGRA_SMC_PMC		0xc2fffe00
+#define  TEGRA_SMC_PMC_READ	0xaa
+#define  TEGRA_SMC_PMC_WRITE	0xbb
+
 #endif	/* PMC_H */
diff --git a/arch/arm/include/asm/arch-tegra/tegra.h b/arch/arm/include/asm/arch-tegra/tegra.h
index 7ae0129e2db3..7a4e0972fb76 100644
--- a/arch/arm/include/asm/arch-tegra/tegra.h
+++ b/arch/arm/include/asm/arch-tegra/tegra.h
@@ -30,7 +30,13 @@
 #define NV_PA_SLINK5_BASE	(NV_PA_APB_MISC_BASE + 0xDC00)
 #define NV_PA_SLINK6_BASE	(NV_PA_APB_MISC_BASE + 0xDE00)
 #define TEGRA_DVC_BASE		(NV_PA_APB_MISC_BASE + 0xD000)
+#if defined(CONFIG_TEGRA20) || defined(CONFIG_TEGRA30) || \
+	defined(CONFIG_TEGRA114) || defined(CONFIG_TEGRA124) || \
+	defined(CONFIG_TEGRA132) || defined(CONFIG_TEGRA210)
 #define NV_PA_PMC_BASE		(NV_PA_APB_MISC_BASE + 0xE400)
+#else
+#define NV_PA_PMC_BASE		0xc360000
+#endif
 #define NV_PA_EMC_BASE		(NV_PA_APB_MISC_BASE + 0xF400)
 #define NV_PA_FUSE_BASE		(NV_PA_APB_MISC_BASE + 0xF800)
 #if defined(CONFIG_TEGRA20) || defined(CONFIG_TEGRA30) || \
diff --git a/arch/arm/mach-tegra/Kconfig b/arch/arm/mach-tegra/Kconfig
index db9198348d3f..28914a34a1b5 100644
--- a/arch/arm/mach-tegra/Kconfig
+++ b/arch/arm/mach-tegra/Kconfig
@@ -35,6 +35,10 @@ config TEGRA_PINCTRL
 config TEGRA_PMC
 	bool
 
+config TEGRA_PMC_SECURE
+	bool
+	depends on TEGRA_PMC
+
 config TEGRA_COMMON
 	bool "Tegra common options"
 	select BINMAN
@@ -127,6 +131,7 @@ config TEGRA210
 	select TEGRA_NO_BPMP
 	select TEGRA_PINCTRL
 	select TEGRA_PMC
+	select TEGRA_PMC_SECURE
 
 config TEGRA186
 	bool "Tegra186 family"
diff --git a/arch/arm/mach-tegra/Makefile b/arch/arm/mach-tegra/Makefile
index 517be21ee5f5..f8bc65aa8b18 100644
--- a/arch/arm/mach-tegra/Makefile
+++ b/arch/arm/mach-tegra/Makefile
@@ -1,6 +1,6 @@
 # SPDX-License-Identifier: GPL-2.0+
 #
-# (C) Copyright 2010-2015 Nvidia Corporation.
+# (C) Copyright 2010-2019 Nvidia Corporation.
 #
 # (C) Copyright 2000-2008
 # Wolfgang Denk, DENX Software Engineering, wd@denx.de.
@@ -27,11 +27,11 @@ obj-y += dt-setup.o
 obj-$(CONFIG_TEGRA_CLOCK_SCALING) += emc.o
 obj-$(CONFIG_TEGRA_GPU) += gpu.o
 obj-$(CONFIG_TEGRA_IVC) += ivc.o
-obj-y += lowlevel_init.o
 ifndef CONFIG_SPL_BUILD
 obj-$(CONFIG_ARMV7_PSCI) += psci.o
 endif
 obj-$(CONFIG_DISPLAY_CPUINFO) += sys_info.o
+obj-y += pmc.o
 
 obj-$(CONFIG_TEGRA20) += tegra20/
 obj-$(CONFIG_TEGRA30) += tegra30/
diff --git a/arch/arm/mach-tegra/clock.c b/arch/arm/mach-tegra/clock.c
index 096330748f2b..c9cd4e6aaeb7 100644
--- a/arch/arm/mach-tegra/clock.c
+++ b/arch/arm/mach-tegra/clock.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (c) 2010-2015, NVIDIA CORPORATION.  All rights reserved.
+ * Copyright (c) 2010-2019, NVIDIA CORPORATION.  All rights reserved.
  */
 
 /* Tegra SoC common clock control functions */
@@ -814,11 +814,16 @@ void tegra30_set_up_pllp(void)
 
 int clock_external_output(int clk_id)
 {
-	struct pmc_ctlr *pmc = (struct pmc_ctlr *)NV_PA_PMC_BASE;
+	u32 val;
 
 	if (clk_id >= 1 && clk_id <= 3) {
-		setbits_le32(&pmc->pmc_clk_out_cntrl,
-			     1 << (2 + (clk_id - 1) * 8));
+		val = tegra_pmc_readl(offsetof(struct pmc_ctlr,
+				      pmc_clk_out_cntrl));
+		val |= 1 << (2 + (clk_id - 1) * 8);
+		tegra_pmc_writel(val,
+				 offsetof(struct pmc_ctlr,
+				 pmc_clk_out_cntrl));
+
 	} else {
 		printf("%s: Unknown output clock id %d\n", __func__, clk_id);
 		return -EINVAL;
diff --git a/arch/arm/mach-tegra/cmd_enterrcm.c b/arch/arm/mach-tegra/cmd_enterrcm.c
index 4e6beb3e5bb4..4a889f0e3422 100644
--- a/arch/arm/mach-tegra/cmd_enterrcm.c
+++ b/arch/arm/mach-tegra/cmd_enterrcm.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0+
 /*
- * Copyright (c) 2012, NVIDIA CORPORATION.  All rights reserved.
+ * Copyright (c) 2012-2019, NVIDIA CORPORATION. All rights reserved.
  *
  * Derived from code (arch/arm/lib/reset.c) that is:
  *
@@ -31,12 +31,10 @@
 static int do_enterrcm(cmd_tbl_t *cmdtp, int flag, int argc,
 		       char * const argv[])
 {
-	struct pmc_ctlr *pmc = (struct pmc_ctlr *)NV_PA_PMC_BASE;
-
 	puts("Entering RCM...\n");
 	udelay(50000);
 
-	pmc->pmc_scratch0 = 2;
+	tegra_pmc_writel(2, PMC_SCRATCH0);
 	disable_interrupts();
 	reset_cpu(0);
 
diff --git a/arch/arm/mach-tegra/cpu.c b/arch/arm/mach-tegra/cpu.c
index 1b6ad074ed8f..3d140760e68f 100644
--- a/arch/arm/mach-tegra/cpu.c
+++ b/arch/arm/mach-tegra/cpu.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (c) 2010-2015, NVIDIA CORPORATION.  All rights reserved.
+ * Copyright (c) 2010-2019, NVIDIA CORPORATION.  All rights reserved.
  */
 
 #include <common.h>
@@ -299,21 +299,19 @@ void enable_cpu_clock(int enable)
 
 static int is_cpu_powered(void)
 {
-	struct pmc_ctlr *pmc = (struct pmc_ctlr *)NV_PA_PMC_BASE;
-
-	return (readl(&pmc->pmc_pwrgate_status) & CPU_PWRED) ? 1 : 0;
+	return (tegra_pmc_readl(offsetof(struct pmc_ctlr,
+				pmc_pwrgate_status)) & CPU_PWRED) ? 1 : 0;
 }
 
 static void remove_cpu_io_clamps(void)
 {
-	struct pmc_ctlr *pmc = (struct pmc_ctlr *)NV_PA_PMC_BASE;
 	u32 reg;
 	debug("%s entry\n", __func__);
 
 	/* Remove the clamps on the CPU I/O signals */
-	reg = readl(&pmc->pmc_remove_clamping);
+	reg = tegra_pmc_readl(offsetof(struct pmc_ctlr, pmc_remove_clamping));
 	reg |= CPU_CLMP;
-	writel(reg, &pmc->pmc_remove_clamping);
+	tegra_pmc_writel(reg, offsetof(struct pmc_ctlr, pmc_remove_clamping));
 
 	/* Give I/O signals time to stabilize */
 	udelay(IO_STABILIZATION_DELAY);
@@ -321,17 +319,19 @@ static void remove_cpu_io_clamps(void)
 
 void powerup_cpu(void)
 {
-	struct pmc_ctlr *pmc = (struct pmc_ctlr *)NV_PA_PMC_BASE;
 	u32 reg;
 	int timeout = IO_STABILIZATION_DELAY;
 	debug("%s entry\n", __func__);
 
 	if (!is_cpu_powered()) {
 		/* Toggle the CPU power state (OFF -> ON) */
-		reg = readl(&pmc->pmc_pwrgate_toggle);
+		reg = tegra_pmc_readl(offsetof(struct pmc_ctlr,
+				      pmc_pwrgate_toggle));
 		reg &= PARTID_CP;
 		reg |= START_CP;
-		writel(reg, &pmc->pmc_pwrgate_toggle);
+		tegra_pmc_writel(reg,
+				 offsetof(struct pmc_ctlr,
+				 pmc_pwrgate_toggle));
 
 		/* Wait for the power to come up */
 		while (!is_cpu_powered()) {
diff --git a/arch/arm/mach-tegra/lowlevel_init.S b/arch/arm/mach-tegra/lowlevel_init.S
deleted file mode 100644
index 626f1b642745..000000000000
--- a/arch/arm/mach-tegra/lowlevel_init.S
+++ /dev/null
@@ -1,39 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0+ */
-/*
- * SoC-specific setup info
- *
- * (C) Copyright 2010,2011
- * NVIDIA Corporation <www.nvidia.com>
- */
-
-#include <config.h>
-#include <linux/linkage.h>
-
-#ifdef CONFIG_ARM64
-	.align	5
-ENTRY(reset_cpu)
-	/* get address for global reset register */
-	ldr	x1, =PRM_RSTCTRL
-	ldr	w3, [x1]
-	/* force reset */
-	orr	w3, w3, #0x10
-	str	w3, [x1]
-	mov	w0, w0
-1:
-	b	1b
-ENDPROC(reset_cpu)
-#else
-	.align	5
-ENTRY(reset_cpu)
-	ldr	r1, rstctl			@ get addr for global reset
-						@ reg
-	ldr	r3, [r1]
-	orr	r3, r3, #0x10
-	str	r3, [r1]			@ force reset
-	mov	r0, r0
-_loop_forever:
-	b	_loop_forever
-rstctl:
-	.word	PRM_RSTCTRL
-ENDPROC(reset_cpu)
-#endif
diff --git a/arch/arm/mach-tegra/pmc.c b/arch/arm/mach-tegra/pmc.c
new file mode 100644
index 000000000000..afd3c54179c1
--- /dev/null
+++ b/arch/arm/mach-tegra/pmc.c
@@ -0,0 +1,92 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2018-2019, NVIDIA CORPORATION. All rights reserved.
+ */
+
+#include <common.h>
+
+#include <linux/arm-smccc.h>
+
+#include <asm/io.h>
+#include <asm/arch-tegra/pmc.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#if IS_ENABLED(CONFIG_TEGRA_PMC_SECURE)
+static bool tegra_pmc_detect_tz_only(void)
+{
+	static bool initialized = false;
+	static bool is_tz_only = false;
+	u32 value, saved;
+
+	if (!initialized) {
+		saved = readl(NV_PA_PMC_BASE + PMC_SCRATCH0);
+		value = saved ^ 0xffffffff;
+
+		if (value == 0xffffffff)
+			value = 0xdeadbeef;
+
+		/* write pattern and read it back */
+		writel(value, NV_PA_PMC_BASE + PMC_SCRATCH0);
+		value = readl(NV_PA_PMC_BASE + PMC_SCRATCH0);
+
+		/* if we read all-zeroes, access is restricted to TZ only */
+		if (value == 0) {
+			debug("access to PMC is restricted to TZ\n");
+			is_tz_only = true;
+		} else {
+			/* restore original value */
+			writel(saved, NV_PA_PMC_BASE + PMC_SCRATCH0);
+		}
+
+		initialized = true;
+	}
+
+	return is_tz_only;
+}
+#endif
+
+uint32_t tegra_pmc_readl(unsigned long offset)
+{
+#if IS_ENABLED(CONFIG_TEGRA_PMC_SECURE)
+	if (tegra_pmc_detect_tz_only()) {
+		struct arm_smccc_res res;
+
+		arm_smccc_smc(TEGRA_SMC_PMC, TEGRA_SMC_PMC_READ, offset, 0, 0,
+			      0, 0, 0, &res);
+		if (res.a0)
+			printf("%s(): SMC failed: %lu\n", __func__, res.a0);
+
+		return res.a1;
+	}
+#endif
+
+	return readl(NV_PA_PMC_BASE + offset);
+}
+
+void tegra_pmc_writel(u32 value, unsigned long offset)
+{
+#if IS_ENABLED(CONFIG_TEGRA_PMC_SECURE)
+	if (tegra_pmc_detect_tz_only()) {
+		struct arm_smccc_res res;
+
+		arm_smccc_smc(TEGRA_SMC_PMC, TEGRA_SMC_PMC_WRITE, offset,
+			      value, 0, 0, 0, 0, &res);
+		if (res.a0)
+			printf("%s(): SMC failed: %lu\n", __func__, res.a0);
+
+		return;
+	}
+#endif
+
+	writel(value, NV_PA_PMC_BASE + offset);
+}
+
+void reset_cpu(ulong addr)
+{
+	u32 value;
+
+	value = tegra_pmc_readl(PMC_CNTRL);
+	value |= PMC_CNTRL_MAIN_RST;
+	tegra_pmc_writel(value, PMC_CNTRL);
+}
diff --git a/arch/arm/mach-tegra/powergate.c b/arch/arm/mach-tegra/powergate.c
index e45f0961b242..761c9ef19e3b 100644
--- a/arch/arm/mach-tegra/powergate.c
+++ b/arch/arm/mach-tegra/powergate.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (c) 2014, NVIDIA CORPORATION.  All rights reserved.
+ * Copyright (c) 2014-2019, NVIDIA CORPORATION.  All rights reserved.
  */
 
 #include <common.h>
@@ -11,6 +11,7 @@
 
 #include <asm/arch/powergate.h>
 #include <asm/arch/tegra.h>
+#include <asm/arch-tegra/pmc.h>
 
 #define PWRGATE_TOGGLE 0x30
 #define  PWRGATE_TOGGLE_START (1 << 8)
@@ -24,18 +25,18 @@ static int tegra_powergate_set(enum tegra_powergate id, bool state)
 	u32 value, mask = state ? (1 << id) : 0, old_mask;
 	unsigned long start, timeout = 25;
 
-	value = readl(NV_PA_PMC_BASE + PWRGATE_STATUS);
+	value = tegra_pmc_readl(PWRGATE_STATUS);
 	old_mask = value & (1 << id);
 
 	if (mask == old_mask)
 		return 0;
 
-	writel(PWRGATE_TOGGLE_START | id, NV_PA_PMC_BASE + PWRGATE_TOGGLE);
+	tegra_pmc_writel(PWRGATE_TOGGLE_START | id, PWRGATE_TOGGLE);
 
 	start = get_timer(0);
 
 	while (get_timer(start) < timeout) {
-		value = readl(NV_PA_PMC_BASE + PWRGATE_STATUS);
+		value = tegra_pmc_readl(PWRGATE_STATUS);
 		if ((value & (1 << id)) == mask)
 			return 0;
 	}
@@ -69,7 +70,7 @@ static int tegra_powergate_remove_clamping(enum tegra_powergate id)
 	else
 		value = 1 << id;
 
-	writel(value, NV_PA_PMC_BASE + REMOVE_CLAMPING);
+	tegra_pmc_writel(value, REMOVE_CLAMPING);
 
 	return 0;
 }

From patchwork Mon Mar 18 23:24:17 2019
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
Subject: [U-Boot, v2,
 10/15] ARM: tegra: Workaround UDC boot issues only if necessary
X-Patchwork-Submitter: Thierry Reding <thierry.reding@gmail.com>
X-Patchwork-Id: 1058157
X-Patchwork-Delegate: twarren@nvidia.com
Message-Id: <20190318232422.24404-11-thierry.reding@gmail.com>
To: Tom Warren <twarren@nvidia.com>
Cc: u-boot@lists.denx.de, Stephen Warren <swarren@nvidia.com>
Date: Tue, 19 Mar 2019 00:24:17 +0100
From: Thierry Reding <thierry.reding@gmail.com>
List-Id: U-Boot discussion <u-boot.lists.denx.de>

From: Thierry Reding <treding@nvidia.com>

Resetting the USB device controller on boot is only necessary if the SoC
actually has a UDC controller and U-Boot enables support for it. All the
Tegra boards support UDC via the ChipIdea UDC driver, so make the UDC on
boot workaround depend on the ChipIdea UDC driver.

This prevents a crash on Tegra186 which does not have the ChipIdea UDC.

Signed-off-by: Thierry Reding <treding@nvidia.com>
---
 arch/arm/mach-tegra/Kconfig | 1 +
 1 file changed, 1 insertion(+)

diff --git a/arch/arm/mach-tegra/Kconfig b/arch/arm/mach-tegra/Kconfig
index 28914a34a1b5..faa73559fd42 100644
--- a/arch/arm/mach-tegra/Kconfig
+++ b/arch/arm/mach-tegra/Kconfig
@@ -148,6 +148,7 @@ endchoice
 
 config TEGRA_DISCONNECT_UDC_ON_BOOT
 	bool "Disconnect USB device mode controller on boot"
+	depends on CI_UDC
 	default y
 	help
 	  When loading U-Boot into RAM over USB protocols using tools such as

From patchwork Mon Mar 18 23:24:18 2019
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
Subject: [U-Boot,v2,11/15] ARM: tegra: Restore DRAM bank count
X-Patchwork-Submitter: Thierry Reding <thierry.reding@gmail.com>
X-Patchwork-Id: 1058154
X-Patchwork-Delegate: twarren@nvidia.com
Message-Id: <20190318232422.24404-12-thierry.reding@gmail.com>
To: Tom Warren <twarren@nvidia.com>
Cc: u-boot@lists.denx.de, Stephen Warren <swarren@nvidia.com>
Date: Tue, 19 Mar 2019 00:24:18 +0100
From: Thierry Reding <thierry.reding@gmail.com>
List-Id: U-Boot discussion <u-boot.lists.denx.de>

From: Thierry Reding <treding@nvidia.com>

Commit 86cf1c82850f ("configs: Migrate CONFIG_NR_DRAM_BANKS") reduced
the number of DRAM banks supported by U-Boot from 1026 to 8 on P2771-000
boards.

However, as explained in commit a9819b9e33bd ("ARM: tegra: p2771-000:
increase max DRAM bank count"), the platform can have a large number of
unusable chunks of memory (up to 1024), so a total of 1026 DRAM banks
are needed to describe the worst-case situation.

In practice the number of DRAM banks needed will typically be much
lower, but we should be prepared to properly deal with the worst case.

Signed-off-by: Thierry Reding <treding@nvidia.com>
---
 configs/p2771-0000-000_defconfig | 2 +-
 configs/p2771-0000-500_defconfig | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/configs/p2771-0000-000_defconfig b/configs/p2771-0000-000_defconfig
index ac85efa37b3b..ad0802067e73 100644
--- a/configs/p2771-0000-000_defconfig
+++ b/configs/p2771-0000-000_defconfig
@@ -2,7 +2,7 @@ CONFIG_ARM=y
 CONFIG_TEGRA=y
 CONFIG_SYS_TEXT_BASE=0x80080000
 CONFIG_TEGRA186=y
-CONFIG_NR_DRAM_BANKS=8
+CONFIG_NR_DRAM_BANKS=1026
 CONFIG_OF_SYSTEM_SETUP=y
 CONFIG_CONSOLE_MUX=y
 CONFIG_SYS_STDIO_DEREGISTER=y
diff --git a/configs/p2771-0000-500_defconfig b/configs/p2771-0000-500_defconfig
index df4d914d85cf..459b67fd195f 100644
--- a/configs/p2771-0000-500_defconfig
+++ b/configs/p2771-0000-500_defconfig
@@ -2,7 +2,7 @@ CONFIG_ARM=y
 CONFIG_TEGRA=y
 CONFIG_SYS_TEXT_BASE=0x80080000
 CONFIG_TEGRA186=y
-CONFIG_NR_DRAM_BANKS=8
+CONFIG_NR_DRAM_BANKS=1026
 CONFIG_OF_SYSTEM_SETUP=y
 CONFIG_CONSOLE_MUX=y
 CONFIG_SYS_STDIO_DEREGISTER=y

From patchwork Mon Mar 18 23:24:19 2019
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
Subject: [U-Boot,v2,12/15] ARM: tegra: Unify Tegra186 builds
X-Patchwork-Submitter: Thierry Reding <thierry.reding@gmail.com>
X-Patchwork-Id: 1058151
X-Patchwork-Delegate: twarren@nvidia.com
Message-Id: <20190318232422.24404-13-thierry.reding@gmail.com>
To: Tom Warren <twarren@nvidia.com>
Cc: u-boot@lists.denx.de, Stephen Warren <swarren@nvidia.com>
Date: Tue, 19 Mar 2019 00:24:19 +0100
From: Thierry Reding <thierry.reding@gmail.com>
List-Id: U-Boot discussion <u-boot.lists.denx.de>

From: Thierry Reding <treding@nvidia.com>

Tegra186 build are currently dealt with in very special ways, which is
because Tegra186 is fundamentally different in many respects. It is no
longer necessary to do many of the low-level programming because early
boot firmware will already have taken care of it.

Unfortunately, separating Tegra186 builds from the rest in this way
makes it difficult to share code with prior generations of Tegra. With
all of the low-level programming code behind Kconfig guards, the build
for Tegra186 can again be unified.

As a side-effect, and partial reason for this change, other Tegra SoC
generations can now make use of the code that deals with taking over a
boot from earlier bootloaders. This used to be nvtboot, but has been
replaced by cboot nowadays. Rename the files and functions related to
this to avoid confusion. The implemented protocols are unchanged.

Signed-off-by: Thierry Reding <treding@nvidia.com>
---
 arch/arm/include/asm/arch-tegra/cboot.h       |  39 ++++
 arch/arm/mach-tegra/Makefile                  |   4 +-
 arch/arm/mach-tegra/board.c                   |  23 ++
 arch/arm/mach-tegra/board186.c                |  32 ---
 arch/arm/mach-tegra/board2.c                  |  21 ++
 .../{tegra186/nvtboot_board.c => cboot.c}     | 202 ++++++++++++++++--
 .../{tegra186/nvtboot_ll.S => cboot_ll.S}     |  12 +-
 arch/arm/mach-tegra/tegra186/Makefile         |   4 -
 arch/arm/mach-tegra/tegra186/nvtboot_mem.c    | 172 ---------------
 board/nvidia/p2771-0000/p2771-0000.c          |  10 +-
 10 files changed, 279 insertions(+), 240 deletions(-)
 create mode 100644 arch/arm/include/asm/arch-tegra/cboot.h
 delete mode 100644 arch/arm/mach-tegra/board186.c
 rename arch/arm/mach-tegra/{tegra186/nvtboot_board.c => cboot.c} (55%)
 rename arch/arm/mach-tegra/{tegra186/nvtboot_ll.S => cboot_ll.S} (57%)
 delete mode 100644 arch/arm/mach-tegra/tegra186/nvtboot_mem.c

diff --git a/arch/arm/include/asm/arch-tegra/cboot.h b/arch/arm/include/asm/arch-tegra/cboot.h
new file mode 100644
index 000000000000..b3441ec178b3
--- /dev/null
+++ b/arch/arm/include/asm/arch-tegra/cboot.h
@@ -0,0 +1,39 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright (c) 2019 NVIDIA Corporation. All rights reserved.
+ */
+
+#ifndef _TEGRA_CBOOT_H_
+#define _TEGRA_CBOOT_H_
+
+#ifdef CONFIG_ARM64
+extern unsigned long cboot_boot_x0;
+
+void cboot_save_boot_params(unsigned long x0, unsigned long x1,
+			    unsigned long x2, unsigned long x3);
+int cboot_dram_init(void);
+int cboot_dram_init_banksize(void);
+ulong cboot_get_usable_ram_top(ulong total_size);
+#else
+static inline void cboot_save_boot_params(unsigned long x0, unsigned long x1,
+					  unsigned long x2, unsigned long x3)
+{
+}
+
+static inline int cboot_dram_init(void)
+{
+	return -ENOSYS;
+}
+
+static inline int cboot_dram_init_banksize(void)
+{
+	return -ENOSYS;
+}
+
+static inline ulong cboot_get_usable_ram_top(ulong total_size)
+{
+	return 0;
+}
+#endif
+
+#endif
diff --git a/arch/arm/mach-tegra/Makefile b/arch/arm/mach-tegra/Makefile
index f8bc65aa8b18..41ba674edff4 100644
--- a/arch/arm/mach-tegra/Makefile
+++ b/arch/arm/mach-tegra/Makefile
@@ -5,7 +5,6 @@
 # (C) Copyright 2000-2008
 # Wolfgang Denk, DENX Software Engineering, wd@denx.de.
 
-ifndef CONFIG_TEGRA186
 ifdef CONFIG_SPL_BUILD
 obj-y += spl.o
 obj-y += cpu.o
@@ -20,9 +19,8 @@ obj-$(CONFIG_TEGRA_CLKRST) += clock.o
 obj-$(CONFIG_TEGRA_PINCTRL) += pinmux-common.o
 obj-$(CONFIG_TEGRA_PMC) += powergate.o
 obj-y += xusb-padctl-dummy.o
-endif
 
-obj-$(CONFIG_ARM64) += arm64-mmu.o
+obj-$(CONFIG_ARM64) += arm64-mmu.o cboot_ll.o cboot.o
 obj-y += dt-setup.o
 obj-$(CONFIG_TEGRA_CLOCK_SCALING) += emc.o
 obj-$(CONFIG_TEGRA_GPU) += gpu.o
diff --git a/arch/arm/mach-tegra/board.c b/arch/arm/mach-tegra/board.c
index 59d2f347485d..c3ba00811e83 100644
--- a/arch/arm/mach-tegra/board.c
+++ b/arch/arm/mach-tegra/board.c
@@ -21,6 +21,7 @@
 #include <asm/arch/tegra.h>
 #include <asm/arch-tegra/ap.h>
 #include <asm/arch-tegra/board.h>
+#include <asm/arch-tegra/cboot.h>
 #include <asm/arch-tegra/pmc.h>
 #include <asm/arch-tegra/sys_proto.h>
 #include <asm/arch-tegra/warmboot.h>
@@ -46,6 +47,21 @@ void save_boot_params(unsigned long r0, unsigned long r1, unsigned long r2,
 		      unsigned long r3)
 {
 	from_spl = r0 != UBOOT_NOT_LOADED_FROM_SPL;
+
+	/*
+	 * The logic for this is somewhat indirect. The purpose of the marker
+	 * (UBOOT_NOT_LOADED_FROM_SPL) is in fact used to determine if U-Boot
+	 * was loaded from a read-only instance of itself, which is something
+	 * that can happen in secure boot setups. So basically the presence
+	 * of the marker is an indication that U-Boot was loaded by one such
+	 * special variant of U-Boot. Conversely, the absence of the marker
+	 * indicates that this instance of U-Boot was loaded by something
+	 * other than a special U-Boot. This could be SPL, but it could just
+	 * as well be one of any number of other first stage bootloaders.
+	 */
+	if (from_spl)
+		cboot_save_boot_params(r0, r1, r2, r3);
+
 	save_boot_params_ret();
 }
 #endif
@@ -127,6 +143,13 @@ static phys_size_t query_sdram_size(void)
 
 int dram_init(void)
 {
+	int err;
+
+	/* try to initialize DRAM from cboot DTB first */
+	err = cboot_dram_init();
+	if (err == 0)
+		return 0;
+
 #if IS_ENABLED(CONFIG_TEGRA_MC)
 	/* We do not initialise DRAM here. We just query the size */
 	gd->ram_size = query_sdram_size();
diff --git a/arch/arm/mach-tegra/board186.c b/arch/arm/mach-tegra/board186.c
deleted file mode 100644
index 80b55707e90f..000000000000
--- a/arch/arm/mach-tegra/board186.c
+++ /dev/null
@@ -1,32 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0+
-/*
- * Copyright (c) 2016, NVIDIA CORPORATION.
- */
-
-#include <common.h>
-#include <asm/arch/tegra.h>
-
-int board_early_init_f(void)
-{
-	return 0;
-}
-
-__weak int tegra_board_init(void)
-{
-	return 0;
-}
-
-int board_init(void)
-{
-	return tegra_board_init();
-}
-
-__weak int tegra_soc_board_init_late(void)
-{
-	return 0;
-}
-
-int board_late_init(void)
-{
-	return tegra_soc_board_init_late();
-}
diff --git a/arch/arm/mach-tegra/board2.c b/arch/arm/mach-tegra/board2.c
index ce1c9346959d..bbc487aa3bf6 100644
--- a/arch/arm/mach-tegra/board2.c
+++ b/arch/arm/mach-tegra/board2.c
@@ -13,6 +13,7 @@
 #include <asm/io.h>
 #include <asm/arch-tegra/ap.h>
 #include <asm/arch-tegra/board.h>
+#include <asm/arch-tegra/cboot.h>
 #include <asm/arch-tegra/clk_rst.h>
 #include <asm/arch-tegra/pmc.h>
 #include <asm/arch-tegra/pmu.h>
@@ -51,6 +52,7 @@ __weak void pin_mux_mmc(void) {}
 __weak void gpio_early_init_uart(void) {}
 __weak void pin_mux_display(void) {}
 __weak void start_cpu_fan(void) {}
+__weak void cboot_late_init(void) {}
 
 #if defined(CONFIG_TEGRA_NAND)
 __weak void pin_mux_nand(void)
@@ -243,6 +245,7 @@ int board_late_init(void)
 	}
 #endif
 	start_cpu_fan();
+	cboot_late_init();
 
 	return 0;
 }
@@ -337,6 +340,15 @@ static ulong usable_ram_size_below_4g(void)
  */
 int dram_init_banksize(void)
 {
+	int err;
+
+	/* try to compute DRAM bank size based on cboot DTB first */
+	err = cboot_dram_init_banksize();
+	if (err == 0)
+		return err;
+
+	/* fall back to default DRAM bank size computation */
+
 	gd->bd->bi_dram[0].start = CONFIG_SYS_SDRAM_BASE;
 	gd->bd->bi_dram[0].size = usable_ram_size_below_4g();
 
@@ -370,5 +382,14 @@ int dram_init_banksize(void)
  */
 ulong board_get_usable_ram_top(ulong total_size)
 {
+	ulong ram_top;
+
+	/* try to get top of usable RAM based on cboot DTB first */
+	ram_top = cboot_get_usable_ram_top(total_size);
+	if (ram_top > 0)
+		return ram_top;
+
+	/* fall back to default usable RAM computation */
+
 	return CONFIG_SYS_SDRAM_BASE + usable_ram_size_below_4g();
 }
diff --git a/arch/arm/mach-tegra/tegra186/nvtboot_board.c b/arch/arm/mach-tegra/cboot.c
similarity index 55%
rename from arch/arm/mach-tegra/tegra186/nvtboot_board.c
rename to arch/arm/mach-tegra/cboot.c
index 83c0e931ea24..2bca98c92898 100644
--- a/arch/arm/mach-tegra/tegra186/nvtboot_board.c
+++ b/arch/arm/mach-tegra/cboot.c
@@ -3,14 +3,182 @@
  * Copyright (c) 2016-2018, NVIDIA CORPORATION.
  */
 
-#include <stdlib.h>
 #include <common.h>
 #include <fdt_support.h>
 #include <fdtdec.h>
+#include <stdlib.h>
+
+#include <linux/sizes.h>
+
 #include <asm/arch/tegra.h>
+#include <asm/arch-tegra/cboot.h>
 #include <asm/armv8/mmu.h>
 
-extern unsigned long nvtboot_boot_x0;
+/*
+ * Size of a region that's large enough to hold the relocated U-Boot and all
+ * other allocations made around it (stack, heap, page tables, etc.)
+ * In practice, running "bdinfo" at the shell prompt, the stack reaches about
+ * 5MB from the address selected for ram_top as of the time of writing,
+ * so a 16MB region should be plenty.
+ */
+#define MIN_USABLE_RAM_SIZE SZ_16M
+/*
+ * The amount of space we expect to require for stack usage. Used to validate
+ * that all reservations fit into the region selected for the relocation target
+ */
+#define MIN_USABLE_STACK_SIZE SZ_1M
+
+DECLARE_GLOBAL_DATA_PTR;
+
+extern struct mm_region tegra_mem_map[];
+
+/*
+ * These variables are written to before relocation, and hence cannot be
+ * in.bss, since .bss overlaps the DTB that's appended to the U-Boot binary.
+ * The section attribute forces this into .data and avoids this issue. This
+ * also has the nice side-effect of the content being valid after relocation.
+ */
+
+/* The number of valid entries in ram_banks[] */
+static int ram_bank_count __attribute__((section(".data")));
+
+/*
+ * The usable top-of-RAM for U-Boot. This is both:
+ * a) Below 4GB to avoid issues with peripherals that use 32-bit addressing.
+ * b) At the end of a region that has enough space to hold the relocated U-Boot
+ *    and all other allocations made around it (stack, heap, page tables, etc.)
+ */
+static u64 ram_top __attribute__((section(".data")));
+/* The base address of the region of RAM that ends at ram_top */
+static u64 region_base __attribute__((section(".data")));
+
+int cboot_dram_init(void)
+{
+	unsigned int na, ns;
+	const void *cboot_blob = (void *)cboot_boot_x0;
+	int node, len, i;
+	const u32 *prop;
+
+	if (!cboot_blob)
+		return -EINVAL;
+
+	na = fdtdec_get_uint(cboot_blob, 0, "#address-cells", 2);
+	ns = fdtdec_get_uint(cboot_blob, 0, "#size-cells", 2);
+
+	node = fdt_path_offset(cboot_blob, "/memory");
+	if (node < 0) {
+		pr_err("Can't find /memory node in cboot DTB");
+		hang();
+	}
+	prop = fdt_getprop(cboot_blob, node, "reg", &len);
+	if (!prop) {
+		pr_err("Can't find /memory/reg property in cboot DTB");
+		hang();
+	}
+
+	/* Calculate the true # of base/size pairs to read */
+	len /= 4;		/* Convert bytes to number of cells */
+	len /= (na + ns);	/* Convert cells to number of banks */
+	if (len > CONFIG_NR_DRAM_BANKS)
+		len = CONFIG_NR_DRAM_BANKS;
+
+	/* Parse the /memory node, and save useful entries */
+	gd->ram_size = 0;
+	ram_bank_count = 0;
+	for (i = 0; i < len; i++) {
+		u64 bank_start, bank_end, bank_size, usable_bank_size;
+
+		/* Extract raw memory region data from DTB */
+		bank_start = fdt_read_number(prop, na);
+		prop += na;
+		bank_size = fdt_read_number(prop, ns);
+		prop += ns;
+		gd->ram_size += bank_size;
+		bank_end = bank_start + bank_size;
+		debug("Bank %d: %llx..%llx (+%llx)\n", i,
+		      bank_start, bank_end, bank_size);
+
+		/*
+		 * Align the bank to MMU section size. This is not strictly
+		 * necessary, since the translation table construction code
+		 * handles page granularity without issue. However, aligning
+		 * the MMU entries reduces the size and number of levels in the
+		 * page table, so is worth it.
+		 */
+		bank_start = ROUND(bank_start, SZ_2M);
+		bank_end = bank_end & ~(SZ_2M - 1);
+		bank_size = bank_end - bank_start;
+		debug("  aligned: %llx..%llx (+%llx)\n",
+		      bank_start, bank_end, bank_size);
+		if (bank_end <= bank_start)
+			continue;
+
+		/* Record data used to create MMU translation tables */
+		ram_bank_count++;
+		/* Index below is deliberately 1-based to skip MMIO entry */
+		tegra_mem_map[ram_bank_count].virt = bank_start;
+		tegra_mem_map[ram_bank_count].phys = bank_start;
+		tegra_mem_map[ram_bank_count].size = bank_size;
+		tegra_mem_map[ram_bank_count].attrs =
+			PTE_BLOCK_MEMTYPE(MT_NORMAL) | PTE_BLOCK_INNER_SHARE;
+
+		/* Determine best bank to relocate U-Boot into */
+		if (bank_end > SZ_4G)
+			bank_end = SZ_4G;
+		debug("  end  %llx (usable)\n", bank_end);
+		usable_bank_size = bank_end - bank_start;
+		debug("  size %llx (usable)\n", usable_bank_size);
+		if ((usable_bank_size >= MIN_USABLE_RAM_SIZE) &&
+		    (bank_end > ram_top)) {
+			ram_top = bank_end;
+			region_base = bank_start;
+			debug("ram top now %llx\n", ram_top);
+		}
+	}
+
+	/* Ensure memory map contains the desired sentinel entry */
+	tegra_mem_map[ram_bank_count + 1].virt = 0;
+	tegra_mem_map[ram_bank_count + 1].phys = 0;
+	tegra_mem_map[ram_bank_count + 1].size = 0;
+	tegra_mem_map[ram_bank_count + 1].attrs = 0;
+
+	/* Error out if a relocation target couldn't be found */
+	if (!ram_top) {
+		pr_err("Can't find a usable RAM top");
+		hang();
+	}
+
+	return 0;
+}
+
+int cboot_dram_init_banksize(void)
+{
+	int i;
+
+	if (ram_bank_count == 0)
+		return -EINVAL;
+
+	if ((gd->start_addr_sp - region_base) < MIN_USABLE_STACK_SIZE) {
+		pr_err("Reservations exceed chosen region size");
+		hang();
+	}
+
+	for (i = 0; i < ram_bank_count; i++) {
+		gd->bd->bi_dram[i].start = tegra_mem_map[1 + i].virt;
+		gd->bd->bi_dram[i].size = tegra_mem_map[1 + i].size;
+	}
+
+#ifdef CONFIG_PCI
+	gd->pci_ram_top = ram_top;
+#endif
+
+	return 0;
+}
+
+ulong cboot_get_usable_ram_top(ulong total_size)
+{
+	return ram_top;
+}
 
 /*
  * The following few functions run late during the boot process and dynamically
@@ -23,8 +191,6 @@ extern unsigned long nvtboot_boot_x0;
  * list of RAM banks into some private data structure before running.
  */
 
-extern struct mm_region tegra_mem_map[];
-
 static char *gen_varname(const char *var, const char *ext)
 {
 	size_t len_var = strlen(var);
@@ -235,7 +401,7 @@ static void set_calculated_env_vars(void)
 	dump_ram_banks();
 #endif
 
-	reserve_ram(nvtboot_boot_x0, fdt_totalsize(nvtboot_boot_x0));
+	reserve_ram(cboot_boot_x0, fdt_totalsize(cboot_boot_x0));
 
 #ifdef DEBUG
 	printf("RAM after reserving cboot DTB:\n");
@@ -262,7 +428,7 @@ static void set_calculated_env_vars(void)
 		debug("%s: var: %s\n", __func__, var);
 		set_calculated_env_var(var);
 #ifdef DEBUG
-		printf("RAM banks affter allocating %s:\n", var);
+		printf("RAM banks after allocating %s:\n", var);
 		dump_ram_banks();
 #endif
 	}
@@ -274,9 +440,9 @@ static int set_fdt_addr(void)
 {
 	int ret;
 
-	ret = env_set_hex("fdt_addr", nvtboot_boot_x0);
+	ret = env_set_hex("fdtaddr", cboot_boot_x0);
 	if (ret) {
-		printf("Failed to set fdt_addr to point at DTB: %d\n", ret);
+		printf("Failed to set fdtaddr to point at DTB: %d\n", ret);
 		return ret;
 	}
 
@@ -284,12 +450,12 @@ static int set_fdt_addr(void)
 }
 
 /*
- * Attempt to use /chosen/nvidia,ether-mac in the nvtboot DTB to U-Boot's
+ * Attempt to use /chosen/nvidia,ethernet-mac in the cboot DTB to U-Boot's
  * ethaddr environment variable if possible.
  */
-static int set_ethaddr_from_nvtboot(void)
+static int set_ethaddr_from_cboot(void)
 {
-	const void *nvtboot_blob = (void *)nvtboot_boot_x0;
+	const void *cboot_blob = (void *)cboot_boot_x0;
 	int ret, node, len;
 	const u32 *prop;
 
@@ -297,27 +463,27 @@ static int set_ethaddr_from_nvtboot(void)
 	if (env_get("ethaddr"))
 		return 0;
 
-	node = fdt_path_offset(nvtboot_blob, "/chosen");
+	node = fdt_path_offset(cboot_blob, "/chosen");
 	if (node < 0) {
-		printf("Can't find /chosen node in nvtboot DTB\n");
+		printf("Can't find /chosen node in cboot DTB\n");
 		return node;
 	}
-	prop = fdt_getprop(nvtboot_blob, node, "nvidia,ether-mac", &len);
+	prop = fdt_getprop(cboot_blob, node, "nvidia,ethernet-mac", &len);
 	if (!prop) {
-		printf("Can't find nvidia,ether-mac property in nvtboot DTB\n");
+		printf("Can't find nvidia,ether-mac property in cboot DTB\n");
 		return -ENOENT;
 	}
 
 	ret = env_set("ethaddr", (void *)prop);
 	if (ret) {
-		printf("Failed to set ethaddr from nvtboot DTB: %d\n", ret);
+		printf("Failed to set ethaddr from cboot DTB: %d\n", ret);
 		return ret;
 	}
 
 	return 0;
 }
 
-int tegra_soc_board_init_late(void)
+int cboot_late_init(void)
 {
 	set_calculated_env_vars();
 	/*
@@ -326,7 +492,7 @@ int tegra_soc_board_init_late(void)
 	 */
 	set_fdt_addr();
 	/* Ignore errors here; not all cases care about Ethernet addresses */
-	set_ethaddr_from_nvtboot();
+	set_ethaddr_from_cboot();
 
 	return 0;
 }
diff --git a/arch/arm/mach-tegra/tegra186/nvtboot_ll.S b/arch/arm/mach-tegra/cboot_ll.S
similarity index 57%
rename from arch/arm/mach-tegra/tegra186/nvtboot_ll.S
rename to arch/arm/mach-tegra/cboot_ll.S
index aa7a863d9702..4c9ddacc2b39 100644
--- a/arch/arm/mach-tegra/tegra186/nvtboot_ll.S
+++ b/arch/arm/mach-tegra/cboot_ll.S
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0+ */
 /*
- * Save nvtboot-related boot-time CPU state
+ * Save cboot-related boot-time CPU state
  *
  * (C) Copyright 2015-2016 NVIDIA Corporation <www.nvidia.com>
  */
@@ -9,12 +9,12 @@
 #include <linux/linkage.h>
 
 .align 8
-.globl	nvtboot_boot_x0
-nvtboot_boot_x0:
+.globl	cboot_boot_x0
+cboot_boot_x0:
 	.dword 0
 
-ENTRY(save_boot_params)
-	adr	x8, nvtboot_boot_x0
+ENTRY(cboot_save_boot_params)
+	adr	x8, cboot_boot_x0
 	str	x0, [x8]
 	b	save_boot_params_ret
-ENDPROC(save_boot_params)
+ENDPROC(cboot_save_boot_params)
diff --git a/arch/arm/mach-tegra/tegra186/Makefile b/arch/arm/mach-tegra/tegra186/Makefile
index 56f3378ecea3..3a2405027704 100644
--- a/arch/arm/mach-tegra/tegra186/Makefile
+++ b/arch/arm/mach-tegra/tegra186/Makefile
@@ -2,8 +2,4 @@
 #
 # SPDX-License-Identifier: GPL-2.0
 
-obj-y += ../board186.o
 obj-y += cache.o
-obj-y += nvtboot_board.o
-obj-y += nvtboot_ll.o
-obj-y += nvtboot_mem.o
diff --git a/arch/arm/mach-tegra/tegra186/nvtboot_mem.c b/arch/arm/mach-tegra/tegra186/nvtboot_mem.c
deleted file mode 100644
index 62142821a595..000000000000
--- a/arch/arm/mach-tegra/tegra186/nvtboot_mem.c
+++ /dev/null
@@ -1,172 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0+
-/*
- * Copyright (c) 2016-2018, NVIDIA CORPORATION.
- */
-
-#include <common.h>
-#include <fdt_support.h>
-#include <fdtdec.h>
-#include <linux/sizes.h>
-#include <asm/arch/tegra.h>
-#include <asm/armv8/mmu.h>
-
-/*
- * Size of a region that's large enough to hold the relocated U-Boot and all
- * other allocations made around it (stack, heap, page tables, etc.)
- * In practice, running "bdinfo" at the shell prompt, the stack reaches about
- * 5MB from the address selected for ram_top as of the time of writing,
- * so a 16MB region should be plenty.
- */
-#define MIN_USABLE_RAM_SIZE SZ_16M
-/*
- * The amount of space we expect to require for stack usage. Used to validate
- * that all reservations fit into the region selected for the relocation target
- */
-#define MIN_USABLE_STACK_SIZE SZ_1M
-
-DECLARE_GLOBAL_DATA_PTR;
-
-extern unsigned long nvtboot_boot_x0;
-extern struct mm_region tegra_mem_map[];
-
-/*
- * These variables are written to before relocation, and hence cannot be
- * in.bss, since .bss overlaps the DTB that's appended to the U-Boot binary.
- * The section attribute forces this into .data and avoids this issue. This
- * also has the nice side-effect of the content being valid after relocation.
- */
-
-/* The number of valid entries in ram_banks[] */
-static int ram_bank_count __attribute__((section(".data")));
-
-/*
- * The usable top-of-RAM for U-Boot. This is both:
- * a) Below 4GB to avoid issues with peripherals that use 32-bit addressing.
- * b) At the end of a region that has enough space to hold the relocated U-Boot
- *    and all other allocations made around it (stack, heap, page tables, etc.)
- */
-static u64 ram_top __attribute__((section(".data")));
-/* The base address of the region of RAM that ends at ram_top */
-static u64 region_base __attribute__((section(".data")));
-
-int dram_init(void)
-{
-	unsigned int na, ns;
-	const void *nvtboot_blob = (void *)nvtboot_boot_x0;
-	int node, len, i;
-	const u32 *prop;
-
-	na = fdtdec_get_uint(nvtboot_blob, 0, "#address-cells", 2);
-	ns = fdtdec_get_uint(nvtboot_blob, 0, "#size-cells", 2);
-
-	node = fdt_path_offset(nvtboot_blob, "/memory");
-	if (node < 0) {
-		pr_err("Can't find /memory node in nvtboot DTB");
-		hang();
-	}
-	prop = fdt_getprop(nvtboot_blob, node, "reg", &len);
-	if (!prop) {
-		pr_err("Can't find /memory/reg property in nvtboot DTB");
-		hang();
-	}
-
-	/* Calculate the true # of base/size pairs to read */
-	len /= 4;		/* Convert bytes to number of cells */
-	len /= (na + ns);	/* Convert cells to number of banks */
-	if (len > CONFIG_NR_DRAM_BANKS)
-		len = CONFIG_NR_DRAM_BANKS;
-
-	/* Parse the /memory node, and save useful entries */
-	gd->ram_size = 0;
-	ram_bank_count = 0;
-	for (i = 0; i < len; i++) {
-		u64 bank_start, bank_end, bank_size, usable_bank_size;
-
-		/* Extract raw memory region data from DTB */
-		bank_start = fdt_read_number(prop, na);
-		prop += na;
-		bank_size = fdt_read_number(prop, ns);
-		prop += ns;
-		gd->ram_size += bank_size;
-		bank_end = bank_start + bank_size;
-		debug("Bank %d: %llx..%llx (+%llx)\n", i,
-		      bank_start, bank_end, bank_size);
-
-		/*
-		 * Align the bank to MMU section size. This is not strictly
-		 * necessary, since the translation table construction code
-		 * handles page granularity without issue. However, aligning
-		 * the MMU entries reduces the size and number of levels in the
-		 * page table, so is worth it.
-		 */
-		bank_start = ROUND(bank_start, SZ_2M);
-		bank_end = bank_end & ~(SZ_2M - 1);
-		bank_size = bank_end - bank_start;
-		debug("  aligned: %llx..%llx (+%llx)\n",
-		      bank_start, bank_end, bank_size);
-		if (bank_end <= bank_start)
-			continue;
-
-		/* Record data used to create MMU translation tables */
-		ram_bank_count++;
-		/* Index below is deliberately 1-based to skip MMIO entry */
-		tegra_mem_map[ram_bank_count].virt = bank_start;
-		tegra_mem_map[ram_bank_count].phys = bank_start;
-		tegra_mem_map[ram_bank_count].size = bank_size;
-		tegra_mem_map[ram_bank_count].attrs =
-			PTE_BLOCK_MEMTYPE(MT_NORMAL) | PTE_BLOCK_INNER_SHARE;
-
-		/* Determine best bank to relocate U-Boot into */
-		if (bank_end > SZ_4G)
-			bank_end = SZ_4G;
-		debug("  end  %llx (usable)\n", bank_end);
-		usable_bank_size = bank_end - bank_start;
-		debug("  size %llx (usable)\n", usable_bank_size);
-		if ((usable_bank_size >= MIN_USABLE_RAM_SIZE) &&
-		    (bank_end > ram_top)) {
-			ram_top = bank_end;
-			region_base = bank_start;
-			debug("ram top now %llx\n", ram_top);
-		}
-	}
-
-	/* Ensure memory map contains the desired sentinel entry */
-	tegra_mem_map[ram_bank_count + 1].virt = 0;
-	tegra_mem_map[ram_bank_count + 1].phys = 0;
-	tegra_mem_map[ram_bank_count + 1].size = 0;
-	tegra_mem_map[ram_bank_count + 1].attrs = 0;
-
-	/* Error out if a relocation target couldn't be found */
-	if (!ram_top) {
-		pr_err("Can't find a usable RAM top");
-		hang();
-	}
-
-	return 0;
-}
-
-int dram_init_banksize(void)
-{
-	int i;
-
-	if ((gd->start_addr_sp - region_base) < MIN_USABLE_STACK_SIZE) {
-		pr_err("Reservations exceed chosen region size");
-		hang();
-	}
-
-	for (i = 0; i < ram_bank_count; i++) {
-		gd->bd->bi_dram[i].start = tegra_mem_map[1 + i].virt;
-		gd->bd->bi_dram[i].size = tegra_mem_map[1 + i].size;
-	}
-
-#ifdef CONFIG_PCI
-	gd->pci_ram_top = ram_top;
-#endif
-
-	return 0;
-}
-
-ulong board_get_usable_ram_top(ulong total_size)
-{
-	return ram_top;
-}
diff --git a/board/nvidia/p2771-0000/p2771-0000.c b/board/nvidia/p2771-0000/p2771-0000.c
index 496e8a02111e..6f88010c18c3 100644
--- a/board/nvidia/p2771-0000/p2771-0000.c
+++ b/board/nvidia/p2771-0000/p2771-0000.c
@@ -7,7 +7,7 @@
 #include <i2c.h>
 #include "../p2571/max77620_init.h"
 
-int tegra_board_init(void)
+void pin_mux_mmc(void)
 {
 	struct udevice *dev;
 	uchar val;
@@ -18,19 +18,18 @@ int tegra_board_init(void)
 	ret = i2c_get_chip_for_busnum(0, MAX77620_I2C_ADDR_7BIT, 1, &dev);
 	if (ret) {
 		printf("%s: Cannot find MAX77620 I2C chip\n", __func__);
-		return ret;
+		return;
 	}
 	/* 0xF2 for 3.3v, enabled: bit7:6 = 11 = enable, bit5:0 = voltage */
 	val = 0xF2;
 	ret = dm_i2c_write(dev, MAX77620_CNFG1_L3_REG, &val, 1);
 	if (ret) {
 		printf("i2c_write 0 0x3c 0x27 failed: %d\n", ret);
-		return ret;
+		return;
 	}
-
-	return 0;
 }
 
+#ifdef CONFIG_PCI_TEGRA
 int tegra_pcie_board_init(void)
 {
 	struct udevice *dev;
@@ -52,3 +51,4 @@ int tegra_pcie_board_init(void)
 
 	return 0;
 }
+#endif

From patchwork Mon Mar 18 23:24:20 2019
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
Subject: [U-Boot, v2,
 13/15] ARM: tegra: Implement cboot_save_boot_params() in C
X-Patchwork-Submitter: Thierry Reding <thierry.reding@gmail.com>
X-Patchwork-Id: 1058159
X-Patchwork-Delegate: twarren@nvidia.com
Message-Id: <20190318232422.24404-14-thierry.reding@gmail.com>
To: Tom Warren <twarren@nvidia.com>
Cc: u-boot@lists.denx.de, Stephen Warren <swarren@nvidia.com>
Date: Tue, 19 Mar 2019 00:24:20 +0100
From: Thierry Reding <thierry.reding@gmail.com>
List-Id: U-Boot discussion <u-boot.lists.denx.de>

From: Thierry Reding <treding@nvidia.com>

This is easier to deal with and works just as well for this simple
function.

Signed-off-by: Thierry Reding <treding@nvidia.com>
---
 arch/arm/mach-tegra/Makefile   |  2 +-
 arch/arm/mach-tegra/cboot.c    | 12 ++++++++++++
 arch/arm/mach-tegra/cboot_ll.S | 20 --------------------
 3 files changed, 13 insertions(+), 21 deletions(-)
 delete mode 100644 arch/arm/mach-tegra/cboot_ll.S

diff --git a/arch/arm/mach-tegra/Makefile b/arch/arm/mach-tegra/Makefile
index 41ba674edff4..7165d70a60da 100644
--- a/arch/arm/mach-tegra/Makefile
+++ b/arch/arm/mach-tegra/Makefile
@@ -20,7 +20,7 @@ obj-$(CONFIG_TEGRA_PINCTRL) += pinmux-common.o
 obj-$(CONFIG_TEGRA_PMC) += powergate.o
 obj-y += xusb-padctl-dummy.o
 
-obj-$(CONFIG_ARM64) += arm64-mmu.o cboot_ll.o cboot.o
+obj-$(CONFIG_ARM64) += arm64-mmu.o cboot.o
 obj-y += dt-setup.o
 obj-$(CONFIG_TEGRA_CLOCK_SCALING) += emc.o
 obj-$(CONFIG_TEGRA_GPU) += gpu.o
diff --git a/arch/arm/mach-tegra/cboot.c b/arch/arm/mach-tegra/cboot.c
index 2bca98c92898..8708c4ec9727 100644
--- a/arch/arm/mach-tegra/cboot.c
+++ b/arch/arm/mach-tegra/cboot.c
@@ -52,6 +52,18 @@ static u64 ram_top __attribute__((section(".data")));
 /* The base address of the region of RAM that ends at ram_top */
 static u64 region_base __attribute__((section(".data")));
 
+/*
+ * Explicitly put this in the .data section because it is written before the
+ * .bss section is zeroed out but it needs to persist.
+ */
+unsigned long cboot_boot_x0 __attribute__((section(".data")));
+
+void cboot_save_boot_params(unsigned long x0, unsigned long x1,
+			    unsigned long x2, unsigned long x3)
+{
+	cboot_boot_x0 = x0;
+}
+
 int cboot_dram_init(void)
 {
 	unsigned int na, ns;
diff --git a/arch/arm/mach-tegra/cboot_ll.S b/arch/arm/mach-tegra/cboot_ll.S
deleted file mode 100644
index 4c9ddacc2b39..000000000000
--- a/arch/arm/mach-tegra/cboot_ll.S
+++ /dev/null
@@ -1,20 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0+ */
-/*
- * Save cboot-related boot-time CPU state
- *
- * (C) Copyright 2015-2016 NVIDIA Corporation <www.nvidia.com>
- */
-
-#include <config.h>
-#include <linux/linkage.h>
-
-.align 8
-.globl	cboot_boot_x0
-cboot_boot_x0:
-	.dword 0
-
-ENTRY(cboot_save_boot_params)
-	adr	x8, cboot_boot_x0
-	str	x0, [x8]
-	b	save_boot_params_ret
-ENDPROC(cboot_save_boot_params)

From patchwork Mon Mar 18 23:24:21 2019
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
Subject: [U-Boot,v2,14/15] ARM: tegra: Implement cboot_get_ethaddr()
X-Patchwork-Submitter: Thierry Reding <thierry.reding@gmail.com>
X-Patchwork-Id: 1058160
X-Patchwork-Delegate: twarren@nvidia.com
Message-Id: <20190318232422.24404-15-thierry.reding@gmail.com>
To: Tom Warren <twarren@nvidia.com>
Cc: u-boot@lists.denx.de, Stephen Warren <swarren@nvidia.com>
Date: Tue, 19 Mar 2019 00:24:21 +0100
From: Thierry Reding <thierry.reding@gmail.com>
List-Id: U-Boot discussion <u-boot.lists.denx.de>

From: Thierry Reding <treding@nvidia.com>

This function will attempt to look up an ethernet address in the DTB
that was passed in from cboot. It does so by first trying to locate the
primary ethernet device for the board (identified by the "ethernet"
alias) and if found, reads the "local-mac-address" property. If the
"ethernet" alias does not exist, or if it points to a device tree node
that doesn't exist, or if the device tree node that it points to does
not have a "local-mac-address" property or if the value is invalid, it
will fall back to the legacy mechanism of looking for the MAC address
stored in the "nvidia,ethernet-mac" property of the "/chosen" node.

Signed-off-by: Thierry Reding <treding@nvidia.com>
---
Changes in v2:
- make dummy static inline to avoid duplicate definitions
---
 arch/arm/include/asm/arch-tegra/cboot.h |  6 ++
 arch/arm/mach-tegra/cboot.c             | 78 ++++++++++++++++++++-----
 2 files changed, 69 insertions(+), 15 deletions(-)

diff --git a/arch/arm/include/asm/arch-tegra/cboot.h b/arch/arm/include/asm/arch-tegra/cboot.h
index b3441ec178b3..021c24617575 100644
--- a/arch/arm/include/asm/arch-tegra/cboot.h
+++ b/arch/arm/include/asm/arch-tegra/cboot.h
@@ -14,6 +14,7 @@ void cboot_save_boot_params(unsigned long x0, unsigned long x1,
 int cboot_dram_init(void);
 int cboot_dram_init_banksize(void);
 ulong cboot_get_usable_ram_top(ulong total_size);
+int cboot_get_ethaddr(const void *fdt, uint8_t mac[ETH_ALEN]);
 #else
 static inline void cboot_save_boot_params(unsigned long x0, unsigned long x1,
 					  unsigned long x2, unsigned long x3)
@@ -34,6 +35,11 @@ static inline ulong cboot_get_usable_ram_top(ulong total_size)
 {
 	return 0;
 }
+
+static inline int cboot_get_ethaddr(const void *fdt, uint8_t mac[ETH_ALEN])
+{
+	return -ENOSYS;
+}
 #endif
 
 #endif
diff --git a/arch/arm/mach-tegra/cboot.c b/arch/arm/mach-tegra/cboot.c
index 8708c4ec9727..c7a38d258cce 100644
--- a/arch/arm/mach-tegra/cboot.c
+++ b/arch/arm/mach-tegra/cboot.c
@@ -4,6 +4,7 @@
  */
 
 #include <common.h>
+#include <environment.h>
 #include <fdt_support.h>
 #include <fdtdec.h>
 #include <stdlib.h>
@@ -465,46 +466,93 @@ static int set_fdt_addr(void)
  * Attempt to use /chosen/nvidia,ethernet-mac in the cboot DTB to U-Boot's
  * ethaddr environment variable if possible.
  */
-static int set_ethaddr_from_cboot(void)
+static int cboot_get_ethaddr_legacy(const void *fdt, uint8_t mac[ETH_ALEN])
 {
-	const void *cboot_blob = (void *)cboot_boot_x0;
-	int ret, node, len;
-	const u32 *prop;
-
-	/* Already a valid address in the environment? If so, keep it */
-	if (env_get("ethaddr"))
-		return 0;
+	const char *prop;
+	int node, len;
 
-	node = fdt_path_offset(cboot_blob, "/chosen");
+	node = fdt_path_offset(fdt, "/chosen");
 	if (node < 0) {
 		printf("Can't find /chosen node in cboot DTB\n");
 		return node;
 	}
-	prop = fdt_getprop(cboot_blob, node, "nvidia,ethernet-mac", &len);
+
+	prop = fdt_getprop(fdt, node, "nvidia,ethernet-mac", &len);
 	if (!prop) {
 		printf("Can't find nvidia,ether-mac property in cboot DTB\n");
 		return -ENOENT;
 	}
 
-	ret = env_set("ethaddr", (void *)prop);
-	if (ret) {
-		printf("Failed to set ethaddr from cboot DTB: %d\n", ret);
-		return ret;
+	eth_parse_enetaddr(prop, mac);
+
+	if (!is_valid_ethaddr(mac)) {
+		printf("Invalid MAC address: %s\n", prop);
+		return -EINVAL;
 	}
 
+	debug("Legacy MAC address: %pM\n", mac);
+
 	return 0;
 }
 
+int cboot_get_ethaddr(const void *fdt, uint8_t mac[ETH_ALEN])
+{
+	int node, len, err = 0;
+	const uchar *prop;
+	const char *path;
+
+	path = fdt_get_alias(fdt, "ethernet");
+	if (!path) {
+		err = -ENOENT;
+		goto out;
+	}
+
+	debug("ethernet alias found: %s\n", path);
+
+	node = fdt_path_offset(fdt, path);
+	if (node < 0) {
+		err = -ENOENT;
+		goto out;
+	}
+
+	prop = fdt_getprop(fdt, node, "local-mac-address", &len);
+	if (!prop) {
+		err = -ENOENT;
+		goto out;
+	}
+
+	if (len != ETH_ALEN) {
+		err = -EINVAL;
+		goto out;
+	}
+
+	debug("MAC address: %pM\n", prop);
+	memcpy(mac, prop, ETH_ALEN);
+
+out:
+	if (err < 0)
+		err = cboot_get_ethaddr_legacy(fdt, mac);
+
+	return err;
+}
+
 int cboot_late_init(void)
 {
+	const void *fdt = (const void *)cboot_boot_x0;
+	uint8_t mac[ETH_ALEN];
+	int err;
+
 	set_calculated_env_vars();
 	/*
 	 * Ignore errors here; the value may not be used depending on
 	 * extlinux.conf or boot script content.
 	 */
 	set_fdt_addr();
+
 	/* Ignore errors here; not all cases care about Ethernet addresses */
-	set_ethaddr_from_cboot();
+	err = cboot_get_ethaddr(fdt, mac);
+	if (!err)
+		eth_env_set_enetaddr("ethaddr", mac);
 
 	return 0;
 }

From patchwork Mon Mar 18 23:24:22 2019
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
Subject: [U-Boot, v2,
 15/15] ARM: tegra: Add NVIDIA Jetson Nano Developer Kit support
X-Patchwork-Submitter: Thierry Reding <thierry.reding@gmail.com>
X-Patchwork-Id: 1058155
X-Patchwork-Delegate: twarren@nvidia.com
Message-Id: <20190318232422.24404-16-thierry.reding@gmail.com>
To: Tom Warren <twarren@nvidia.com>
Cc: u-boot@lists.denx.de, Stephen Warren <swarren@nvidia.com>
Date: Tue, 19 Mar 2019 00:24:22 +0100
From: Thierry Reding <thierry.reding@gmail.com>
List-Id: U-Boot discussion <u-boot.lists.denx.de>

From: Thierry Reding <treding@nvidia.com>

The Jetson Nano Developer Kit is a Tegra X1 based development board. It
is similar to Jetson TX1 but it is not pin compatible. It features 4 GB
of LPDDR4, an SPI NOR flash for early boot firmware and an SD card slot
used for storage.

HDMI 2.0 or DP 1.2 are available for display, four USB ports (3 USB 2.0
and 1 USB 3.0) can be used to attach a variety of peripherals and a PCI
Ethernet controller provides onboard network connectivity.

A 40-pin header on the board can be used to extend the capabilities and
exposed interfaces of the Jetson Nano.

Signed-off-by: Thierry Reding <treding@nvidia.com>
---
 arch/arm/dts/tegra210-p3450-0000.dts          | 130 +++++++++
 arch/arm/mach-tegra/tegra210/Kconfig          |   7 +
 board/nvidia/p3450-0000/Kconfig               |  12 +
 board/nvidia/p3450-0000/MAINTAINERS           |   6 +
 board/nvidia/p3450-0000/Makefile              |   8 +
 board/nvidia/p3450-0000/p3450-0000.c          | 143 ++++++++++
 .../p3450-0000/pinmux-config-p3450-0000.h     | 257 ++++++++++++++++++
 configs/p3450-0000_defconfig                  |  54 ++++
 include/configs/p3450-0000.h                  |  44 +++
 9 files changed, 661 insertions(+)
 create mode 100644 arch/arm/dts/tegra210-p3450-0000.dts
 create mode 100644 board/nvidia/p3450-0000/Kconfig
 create mode 100644 board/nvidia/p3450-0000/MAINTAINERS
 create mode 100644 board/nvidia/p3450-0000/Makefile
 create mode 100644 board/nvidia/p3450-0000/p3450-0000.c
 create mode 100644 board/nvidia/p3450-0000/pinmux-config-p3450-0000.h
 create mode 100644 configs/p3450-0000_defconfig
 create mode 100644 include/configs/p3450-0000.h

diff --git a/arch/arm/dts/tegra210-p3450-0000.dts b/arch/arm/dts/tegra210-p3450-0000.dts
new file mode 100644
index 000000000000..a2119165e2f6
--- /dev/null
+++ b/arch/arm/dts/tegra210-p3450-0000.dts
@@ -0,0 +1,130 @@
+/dts-v1/;
+
+#include "tegra210.dtsi"
+
+/ {
+	model = "NVIDIA Jetson Nano Development Kit";
+	compatible = "nvidia,p3450-0000", "nvidia,tegra210";
+
+	chosen {
+		stdout-path = &uarta;
+	};
+
+	aliases {
+		i2c0 = "/i2c@7000d000";
+		i2c2 = "/i2c@7000c400";
+		i2c3 = "/i2c@7000c500";
+		i2c4 = "/i2c@7000c700";
+		sdhci0 = "/sdhci@700b0600";
+		sdhci1 = "/sdhci@700b0000";
+		spi0 = "/spi@70410000";
+		usb0 = "/usb@7d000000";
+	};
+
+	memory {
+		reg = <0x0 0x80000000 0x0 0xc0000000>;
+	};
+
+	pcie-controller@01003000 {
+		status = "okay";
+
+		pci@1,0 {
+			status = "okay";
+		};
+
+		pci@2,0 {
+			status = "okay";
+		};
+	};
+
+	serial@70006000 {
+		status = "okay";
+	};
+
+	padctl@7009f000 {
+		pinctrl-0 = <&padctl_default>;
+		pinctrl-names = "default";
+
+		padctl_default: pinmux {
+			xusb {
+				nvidia,lanes = "otg-1", "otg-2";
+				nvidia,function = "xusb";
+				nvidia,iddq = <0>;
+			};
+
+			usb3 {
+				nvidia,lanes = "pcie-5", "pcie-6";
+				nvidia,function = "usb3";
+				nvidia,iddq = <0>;
+			};
+
+			pcie-x1 {
+				nvidia,lanes = "pcie-0";
+				nvidia,function = "pcie-x1";
+				nvidia,iddq = <0>;
+			};
+
+			pcie-x4 {
+				nvidia,lanes = "pcie-1", "pcie-2",
+					       "pcie-3", "pcie-4";
+				nvidia,function = "pcie-x4";
+				nvidia,iddq = <0>;
+			};
+
+			sata {
+				nvidia,lanes = "sata-0";
+				nvidia,function = "sata";
+				nvidia,iddq = <0>;
+			};
+		};
+	};
+
+	sdhci@700b0000 {
+		status = "okay";
+		cd-gpios = <&gpio TEGRA_GPIO(Z, 1) GPIO_ACTIVE_LOW>;
+		power-gpios = <&gpio TEGRA_GPIO(Z, 3) GPIO_ACTIVE_HIGH>;
+		bus-width = <4>;
+	};
+
+	i2c@7000c400 {
+		status = "okay";
+		clock-frequency = <400000>;
+	};
+
+	i2c@7000c500 {
+		status = "okay";
+		clock-frequency = <400000>;
+	};
+
+	i2c@7000c700 {
+		status = "okay";
+		clock-frequency = <400000>;
+	};
+
+	i2c@7000d000 {
+		status = "okay";
+		clock-frequency = <400000>;
+	};
+
+	spi@70410000 {
+		status = "okay";
+	};
+
+	usb@7d000000 {
+		status = "okay";
+		dr_mode = "peripheral";
+	};
+
+	clocks {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		clk32k_in: clock@0 {
+			compatible = "fixed-clock";
+			reg = <0>;
+			#clock-cells = <0>;
+			clock-frequency = <32768>;
+		};
+	};
+};
diff --git a/arch/arm/mach-tegra/tegra210/Kconfig b/arch/arm/mach-tegra/tegra210/Kconfig
index 250738aed312..60dde5435940 100644
--- a/arch/arm/mach-tegra/tegra210/Kconfig
+++ b/arch/arm/mach-tegra/tegra210/Kconfig
@@ -35,6 +35,12 @@ config TARGET_P2571
 	help
 	  P2571 is a P2530 married to a P1963 I/O board
 
+config TARGET_P3450_0000
+	bool "NVIDIA Jetson Nano Development Kit"
+	select BOARD_LATE_INIT
+	help
+	  P3450-0000 is a P3448 CPU board married to a P3449 I/O board.
+
 endchoice
 
 config SYS_SOC
@@ -47,5 +53,6 @@ source "board/nvidia/e2220-1170/Kconfig"
 source "board/nvidia/p2371-0000/Kconfig"
 source "board/nvidia/p2371-2180/Kconfig"
 source "board/nvidia/p2571/Kconfig"
+source "board/nvidia/p3450-0000/Kconfig"
 
 endif
diff --git a/board/nvidia/p3450-0000/Kconfig b/board/nvidia/p3450-0000/Kconfig
new file mode 100644
index 000000000000..7a08cd88675f
--- /dev/null
+++ b/board/nvidia/p3450-0000/Kconfig
@@ -0,0 +1,12 @@
+if TARGET_P3450_0000
+
+config SYS_BOARD
+	default "p3450-0000"
+
+config SYS_VENDOR
+	default "nvidia"
+
+config SYS_CONFIG_NAME
+	default "p3450-0000"
+
+endif
diff --git a/board/nvidia/p3450-0000/MAINTAINERS b/board/nvidia/p3450-0000/MAINTAINERS
new file mode 100644
index 000000000000..40700066bf39
--- /dev/null
+++ b/board/nvidia/p3450-0000/MAINTAINERS
@@ -0,0 +1,6 @@
+P3450-0000 BOARD
+M:	Tom Warren <twarren@nvidia.com>
+S:	Maintained
+F:	board/nvidia/p3450-0000/
+F:	include/configs/p3450-0000.h
+F:	configs/p3450-0000_defconfig
diff --git a/board/nvidia/p3450-0000/Makefile b/board/nvidia/p3450-0000/Makefile
new file mode 100644
index 000000000000..993c506d8200
--- /dev/null
+++ b/board/nvidia/p3450-0000/Makefile
@@ -0,0 +1,8 @@
+#
+# (C) Copyright 2018
+# NVIDIA Corporation <www.nvidia.com>
+#
+# SPDX-License-Identifier:     GPL-2.0+
+#
+
+obj-y	+= p3450-0000.o
diff --git a/board/nvidia/p3450-0000/p3450-0000.c b/board/nvidia/p3450-0000/p3450-0000.c
new file mode 100644
index 000000000000..fc13185c36b6
--- /dev/null
+++ b/board/nvidia/p3450-0000/p3450-0000.c
@@ -0,0 +1,143 @@
+/*
+ * (C) Copyright 2018
+ * NVIDIA Corporation <www.nvidia.com>
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#include <common.h>
+#include <environment.h>
+#include <i2c.h>
+#include <linux/libfdt.h>
+#include <pca953x.h>
+#include <asm/arch-tegra/cboot.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/pinmux.h>
+#include "../p2571/max77620_init.h"
+#include "pinmux-config-p3450-0000.h"
+
+void pin_mux_mmc(void)
+{
+	struct udevice *dev;
+	uchar val;
+	int ret;
+
+	/* Turn on MAX77620 LDO2 to 3.3V for SD card power */
+	debug("%s: Set LDO2 for VDDIO_SDMMC_AP power to 3.3V\n", __func__);
+	ret = i2c_get_chip_for_busnum(0, MAX77620_I2C_ADDR_7BIT, 1, &dev);
+	if (ret) {
+		printf("%s: Cannot find MAX77620 I2C chip\n", __func__);
+		return;
+	}
+	/* 0xF2 for 3.3v, enabled: bit7:6 = 11 = enable, bit5:0 = voltage */
+	val = 0xF2;
+	ret = dm_i2c_write(dev, MAX77620_CNFG1_L2_REG, &val, 1);
+	if (ret)
+		printf("i2c_write 0 0x3c 0x27 failed: %d\n", ret);
+
+	/* Disable LDO4 discharge */
+	ret = dm_i2c_read(dev, MAX77620_CNFG2_L4_REG, &val, 1);
+	if (ret) {
+		printf("i2c_read 0 0x3c 0x2c failed: %d\n", ret);
+	} else {
+		val &= ~BIT(1); /* ADE */
+		ret = dm_i2c_write(dev, MAX77620_CNFG2_L4_REG, &val, 1);
+		if (ret)
+			printf("i2c_write 0 0x3c 0x2c failed: %d\n", ret);
+	}
+
+	/* Set MBLPD */
+	ret = dm_i2c_read(dev, MAX77620_CNFGGLBL1_REG, &val, 1);
+	if (ret) {
+		printf("i2c_write 0 0x3c 0x00 failed: %d\n", ret);
+	} else {
+		val |= BIT(6); /* MBLPD */
+		ret = dm_i2c_write(dev, MAX77620_CNFGGLBL1_REG, &val, 1);
+		if (ret)
+			printf("i2c_write 0 0x3c 0x00 failed: %d\n", ret);
+	}
+}
+
+/*
+ * Routine: pinmux_init
+ * Description: Do individual peripheral pinmux configs
+ */
+void pinmux_init(void)
+{
+	pinmux_clear_tristate_input_clamping();
+
+	gpio_config_table(p3450_0000_gpio_inits,
+			  ARRAY_SIZE(p3450_0000_gpio_inits));
+
+	pinmux_config_pingrp_table(p3450_0000_pingrps,
+				   ARRAY_SIZE(p3450_0000_pingrps));
+
+	pinmux_config_drvgrp_table(p3450_0000_drvgrps,
+				   ARRAY_SIZE(p3450_0000_drvgrps));
+}
+
+#ifdef CONFIG_PCI_TEGRA
+int tegra_pcie_board_init(void)
+{
+	struct udevice *dev;
+	uchar val;
+	int ret;
+
+	/* Turn on MAX77620 LDO1 to 1.05V for PEX power */
+	debug("%s: Set LDO1 for PEX power to 1.05V\n", __func__);
+	ret = i2c_get_chip_for_busnum(0, MAX77620_I2C_ADDR_7BIT, 1, &dev);
+	if (ret) {
+		printf("%s: Cannot find MAX77620 I2C chip\n", __func__);
+		return -1;
+	}
+	/* 0xCA for 1.05v, enabled: bit7:6 = 11 = enable, bit5:0 = voltage */
+	val = 0xCA;
+	ret = dm_i2c_write(dev, MAX77620_CNFG1_L1_REG, &val, 1);
+	if (ret)
+		printf("i2c_write 0 0x3c 0x25 failed: %d\n", ret);
+
+	return 0;
+}
+#endif /* PCI */
+
+int ft_board_setup(void *fdt, bd_t *bd)
+{
+	const void *cboot_fdt = (const void *)cboot_boot_x0;
+	uint8_t mac[ETH_ALEN], local_mac[ETH_ALEN];
+	const char *path;
+	int offset, err;
+
+	err = cboot_get_ethaddr(cboot_fdt, local_mac);
+	if (err < 0)
+		memset(local_mac, 0, ETH_ALEN);
+
+	path = fdt_get_alias(fdt, "ethernet");
+	if (!path)
+		return 0;
+
+	debug("ethernet alias found: %s\n", path);
+
+	offset = fdt_path_offset(fdt, path);
+	if (offset < 0)
+		return 0;
+
+	debug("PCI ethernet device tree node found\n");
+
+	if (is_valid_ethaddr(local_mac)) {
+		err = fdt_setprop(fdt, offset, "local-mac-address", local_mac,
+				  ETH_ALEN);
+		if (!err)
+			debug("Local MAC address set: %pM\n", local_mac);
+	}
+
+	if (eth_env_get_enetaddr("ethaddr", mac)) {
+		if (memcmp(local_mac, mac, ETH_ALEN) != 0) {
+			err = fdt_setprop(fdt, offset, "mac-address", mac,
+					  ETH_ALEN);
+			if (!err)
+				debug("MAC address set: %pM\n", mac);
+		}
+	}
+
+	return 0;
+}
diff --git a/board/nvidia/p3450-0000/pinmux-config-p3450-0000.h b/board/nvidia/p3450-0000/pinmux-config-p3450-0000.h
new file mode 100644
index 000000000000..d491bffccd72
--- /dev/null
+++ b/board/nvidia/p3450-0000/pinmux-config-p3450-0000.h
@@ -0,0 +1,257 @@
+/*
+ * Copyright (c) 2018-2019, NVIDIA CORPORATION. All rights reserved.
+ *
+ * SPDX-License-Identifier: GPL-2.0+
+ */
+
+/*
+ * THIS FILE IS AUTO-GENERATED - DO NOT EDIT!
+ *
+ * To generate this file, use the tegra-pinmux-scripts tool available from
+ * https://github.com/NVIDIA/tegra-pinmux-scripts
+ * Run "board-to-uboot.py p3450-0000".
+ */
+
+#ifndef _PINMUX_CONFIG_P3450_0000_H_
+#define _PINMUX_CONFIG_P3450_0000_H_
+
+#define GPIO_INIT(_port, _gpio, _init)			\
+	{						\
+		.gpio	= TEGRA_GPIO(_port, _gpio),	\
+		.init	= TEGRA_GPIO_INIT_##_init,	\
+	}
+
+static const struct tegra_gpio_config p3450_0000_gpio_inits[] = {
+	/*        port, pin, init_val */
+	GPIO_INIT(A,    5,   IN),
+	GPIO_INIT(A,    6,   OUT0),
+	GPIO_INIT(B,    4,   IN),
+	GPIO_INIT(B,    5,   IN),
+	GPIO_INIT(B,    6,   IN),
+	GPIO_INIT(B,    7,   IN),
+	GPIO_INIT(C,    0,   IN),
+	GPIO_INIT(C,    1,   IN),
+	GPIO_INIT(C,    2,   IN),
+	GPIO_INIT(C,    3,   IN),
+	GPIO_INIT(C,    4,   IN),
+	GPIO_INIT(E,    6,   IN),
+	GPIO_INIT(G,    2,   IN),
+	GPIO_INIT(G,    3,   IN),
+	GPIO_INIT(H,    0,   OUT0),
+	GPIO_INIT(H,    2,   IN),
+	GPIO_INIT(H,    3,   OUT0),
+	GPIO_INIT(H,    4,   OUT0),
+	GPIO_INIT(H,    5,   IN),
+	GPIO_INIT(H,    6,   IN),
+	GPIO_INIT(H,    7,   OUT0),
+	GPIO_INIT(I,    0,   OUT0),
+	GPIO_INIT(I,    1,   IN),
+	GPIO_INIT(I,    2,   OUT0),
+	GPIO_INIT(J,    4,   IN),
+	GPIO_INIT(J,    5,   IN),
+	GPIO_INIT(J,    6,   IN),
+	GPIO_INIT(J,    7,   IN),
+	GPIO_INIT(S,    5,   IN),
+	GPIO_INIT(S,    7,   OUT0),
+	GPIO_INIT(T,    0,   OUT0),
+	GPIO_INIT(V,    0,   IN),
+	GPIO_INIT(V,    1,   IN),
+	GPIO_INIT(X,    3,   OUT1),
+	GPIO_INIT(X,    4,   IN),
+	GPIO_INIT(X,    5,   IN),
+	GPIO_INIT(X,    6,   IN),
+	GPIO_INIT(Y,    1,   IN),
+	GPIO_INIT(Y,    2,   IN),
+	GPIO_INIT(Z,    0,   IN),
+	GPIO_INIT(Z,    2,   IN),
+	GPIO_INIT(Z,    3,   OUT0),
+	GPIO_INIT(BB,   0,   IN),
+	GPIO_INIT(CC,   4,   IN),
+	GPIO_INIT(DD,   0,   IN),
+};
+
+#define PINCFG(_pingrp, _mux, _pull, _tri, _io, _od, _e_io_hv)	\
+	{							\
+		.pingrp		= PMUX_PINGRP_##_pingrp,	\
+		.func		= PMUX_FUNC_##_mux,		\
+		.pull		= PMUX_PULL_##_pull,		\
+		.tristate	= PMUX_TRI_##_tri,		\
+		.io		= PMUX_PIN_##_io,		\
+		.od		= PMUX_PIN_OD_##_od,		\
+		.e_io_hv	= PMUX_PIN_E_IO_HV_##_e_io_hv,	\
+		.lock		= PMUX_PIN_LOCK_DEFAULT,	\
+	}
+
+static const struct pmux_pingrp_config p3450_0000_pingrps[] = {
+	/*     pingrp,               mux,        pull,   tri,      e_input, od,      e_io_hv */
+	PINCFG(PEX_L0_RST_N_PA0,     PE0,        NORMAL, NORMAL,   OUTPUT,  DISABLE, NORMAL),
+	PINCFG(PEX_L0_CLKREQ_N_PA1,  PE0,        NORMAL, NORMAL,   INPUT,   DISABLE, NORMAL),
+	PINCFG(PEX_WAKE_N_PA2,       PE,         NORMAL, NORMAL,   INPUT,   DISABLE, NORMAL),
+	PINCFG(PEX_L1_RST_N_PA3,     PE1,        NORMAL, NORMAL,   OUTPUT,  DISABLE, NORMAL),
+	PINCFG(PEX_L1_CLKREQ_N_PA4,  PE1,        NORMAL, NORMAL,   INPUT,   DISABLE, NORMAL),
+	PINCFG(SATA_LED_ACTIVE_PA5,  DEFAULT,    UP,     NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(PA6,                  DEFAULT,    NORMAL, NORMAL,   OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(SPI2_MOSI_PB4,        DEFAULT,    DOWN,   NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(SPI2_MISO_PB5,        DEFAULT,    DOWN,   NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(SPI2_SCK_PB6,         DEFAULT,    DOWN,   NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(SPI2_CS0_PB7,         DEFAULT,    DOWN,   NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(SPI1_MOSI_PC0,        DEFAULT,    DOWN,   NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(SPI1_MISO_PC1,        DEFAULT,    DOWN,   NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(SPI1_SCK_PC2,         DEFAULT,    DOWN,   NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(SPI1_CS0_PC3,         DEFAULT,    UP,     NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(SPI1_CS1_PC4,         DEFAULT,    UP,     NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(SPI4_SCK_PC5,         RSVD1,      DOWN,   TRISTATE, OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(SPI4_CS0_PC6,         RSVD1,      DOWN,   TRISTATE, OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(SPI4_MOSI_PC7,        RSVD1,      DOWN,   TRISTATE, OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(SPI4_MISO_PD0,        RSVD1,      DOWN,   TRISTATE, OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(UART3_TX_PD1,         UARTC,      NORMAL, NORMAL,   OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(UART3_RX_PD2,         UARTC,      NORMAL, NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(UART3_RTS_PD3,        UARTC,      UP,     NORMAL,   OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(UART3_CTS_PD4,        UARTC,      UP,     NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(DMIC1_CLK_PE0,        I2S3,       NORMAL, NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(DMIC1_DAT_PE1,        I2S3,       NORMAL, NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(DMIC2_CLK_PE2,        I2S3,       NORMAL, NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(DMIC2_DAT_PE3,        I2S3,       NORMAL, NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(DMIC3_CLK_PE4,        RSVD2,      DOWN,   TRISTATE, OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(DMIC3_DAT_PE5,        RSVD2,      DOWN,   TRISTATE, OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(PE6,                  DEFAULT,    DOWN,   NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(PE7,                  PWM3,       NORMAL, NORMAL,   OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(GEN3_I2C_SCL_PF0,     I2C3,       NORMAL, NORMAL,   INPUT,   DISABLE, NORMAL),
+	PINCFG(GEN3_I2C_SDA_PF1,     I2C3,       NORMAL, NORMAL,   INPUT,   DISABLE, NORMAL),
+	PINCFG(UART2_TX_PG0,         UARTB,      NORMAL, NORMAL,   OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(UART2_RX_PG1,         UARTB,      DOWN,   NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(UART2_RTS_PG2,        DEFAULT,    DOWN,   NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(UART2_CTS_PG3,        DEFAULT,    DOWN,   NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(WIFI_EN_PH0,          DEFAULT,    NORMAL, NORMAL,   OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(WIFI_RST_PH1,         RSVD0,      DOWN,   TRISTATE, OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(WIFI_WAKE_AP_PH2,     DEFAULT,    DOWN,   NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(AP_WAKE_BT_PH3,       DEFAULT,    NORMAL, NORMAL,   OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(BT_RST_PH4,           DEFAULT,    NORMAL, NORMAL,   OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(BT_WAKE_AP_PH5,       DEFAULT,    UP,     NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(PH6,                  DEFAULT,    UP,     NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(AP_WAKE_NFC_PH7,      DEFAULT,    NORMAL, NORMAL,   OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(NFC_EN_PI0,           DEFAULT,    NORMAL, NORMAL,   OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(NFC_INT_PI1,          DEFAULT,    DOWN,   NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(GPS_EN_PI2,           DEFAULT,    NORMAL, NORMAL,   OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(GPS_RST_PI3,          RSVD0,      DOWN,   TRISTATE, OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(UART4_TX_PI4,         UARTD,      NORMAL, NORMAL,   OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(UART4_RX_PI5,         UARTD,      NORMAL, NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(UART4_RTS_PI6,        UARTD,      NORMAL, NORMAL,   OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(UART4_CTS_PI7,        UARTD,      UP,     NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(GEN1_I2C_SDA_PJ0,     I2C1,       NORMAL, NORMAL,   INPUT,   DISABLE, HIGH),
+	PINCFG(GEN1_I2C_SCL_PJ1,     I2C1,       NORMAL, NORMAL,   INPUT,   DISABLE, HIGH),
+	PINCFG(GEN2_I2C_SCL_PJ2,     I2C2,       NORMAL, NORMAL,   INPUT,   DISABLE, HIGH),
+	PINCFG(GEN2_I2C_SDA_PJ3,     I2C2,       NORMAL, NORMAL,   INPUT,   DISABLE, HIGH),
+	PINCFG(PK0,                  RSVD2,      DOWN,   TRISTATE, OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(PK1,                  RSVD2,      DOWN,   TRISTATE, OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(PK2,                  RSVD2,      DOWN,   TRISTATE, OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(PK3,                  RSVD2,      DOWN,   TRISTATE, OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(PK4,                  RSVD1,      DOWN,   TRISTATE, OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(PK5,                  RSVD1,      DOWN,   TRISTATE, OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(PK6,                  RSVD1,      DOWN,   TRISTATE, OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(PK7,                  RSVD1,      DOWN,   TRISTATE, OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(PL0,                  RSVD0,      DOWN,   TRISTATE, OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(PL1,                  RSVD1,      DOWN,   TRISTATE, OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(SDMMC1_CLK_PM0,       SDMMC1,     NORMAL, NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(SDMMC1_CMD_PM1,       SDMMC1,     UP,     NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(SDMMC1_DAT3_PM2,      SDMMC1,     UP,     NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(SDMMC1_DAT2_PM3,      SDMMC1,     UP,     NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(SDMMC1_DAT1_PM4,      SDMMC1,     UP,     NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(SDMMC1_DAT0_PM5,      SDMMC1,     UP,     NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(SDMMC3_CLK_PP0,       SDMMC3,     NORMAL, NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(SDMMC3_CMD_PP1,       SDMMC3,     UP,     NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(SDMMC3_DAT3_PP2,      SDMMC3,     UP,     NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(SDMMC3_DAT2_PP3,      SDMMC3,     UP,     NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(SDMMC3_DAT1_PP4,      SDMMC3,     UP,     NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(SDMMC3_DAT0_PP5,      SDMMC3,     UP,     NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(CAM1_MCLK_PS0,        EXTPERIPH3, NORMAL, NORMAL,   OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(CAM2_MCLK_PS1,        EXTPERIPH3, NORMAL, NORMAL,   OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(CAM_I2C_SCL_PS2,      I2CVI,      NORMAL, NORMAL,   INPUT,   DISABLE, HIGH),
+	PINCFG(CAM_I2C_SDA_PS3,      I2CVI,      NORMAL, NORMAL,   INPUT,   DISABLE, HIGH),
+	PINCFG(CAM_RST_PS4,          RSVD1,      DOWN,   TRISTATE, OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(CAM_AF_EN_PS5,        DEFAULT,    UP,     NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(CAM_FLASH_EN_PS6,     RSVD2,      DOWN,   TRISTATE, OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(CAM1_PWDN_PS7,        DEFAULT,    NORMAL, NORMAL,   OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(CAM2_PWDN_PT0,        DEFAULT,    NORMAL, NORMAL,   OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(CAM1_STROBE_PT1,      RSVD1,      DOWN,   TRISTATE, OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(UART1_TX_PU0,         UARTA,      NORMAL, NORMAL,   OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(UART1_RX_PU1,         UARTA,      NORMAL, NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(UART1_RTS_PU2,        RSVD1,      DOWN,   TRISTATE, OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(UART1_CTS_PU3,        RSVD1,      DOWN,   TRISTATE, OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(LCD_BL_PWM_PV0,       DEFAULT,    DOWN,   NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(LCD_BL_EN_PV1,        DEFAULT,    NORMAL, NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(LCD_RST_PV2,          RSVD0,      DOWN,   TRISTATE, OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(LCD_GPIO1_PV3,        RSVD1,      DOWN,   TRISTATE, OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(LCD_GPIO2_PV4,        PWM1,       NORMAL, NORMAL,   OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(AP_READY_PV5,         RSVD0,      DOWN,   TRISTATE, OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(TOUCH_RST_PV6,        RSVD0,      DOWN,   TRISTATE, OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(TOUCH_CLK_PV7,        RSVD1,      DOWN,   TRISTATE, OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(MODEM_WAKE_AP_PX0,    RSVD0,      DOWN,   TRISTATE, OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(TOUCH_INT_PX1,        RSVD0,      DOWN,   TRISTATE, OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(MOTION_INT_PX2,       RSVD0,      DOWN,   TRISTATE, OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(ALS_PROX_INT_PX3,     DEFAULT,    NORMAL, NORMAL,   OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(TEMP_ALERT_PX4,       DEFAULT,    UP,     NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(BUTTON_POWER_ON_PX5,  DEFAULT,    UP,     NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(BUTTON_VOL_UP_PX6,    DEFAULT,    UP,     NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(BUTTON_VOL_DOWN_PX7,  RSVD0,      DOWN,   TRISTATE, OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(BUTTON_SLIDE_SW_PY0,  RSVD0,      DOWN,   TRISTATE, OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(BUTTON_HOME_PY1,      DEFAULT,    UP,     NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(LCD_TE_PY2,           DEFAULT,    DOWN,   NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(PWR_I2C_SCL_PY3,      I2CPMU,     NORMAL, NORMAL,   INPUT,   DISABLE, NORMAL),
+	PINCFG(PWR_I2C_SDA_PY4,      I2CPMU,     NORMAL, NORMAL,   INPUT,   DISABLE, NORMAL),
+	PINCFG(CLK_32K_OUT_PY5,      RSVD2,      DOWN,   TRISTATE, OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(PZ0,                  DEFAULT,    UP,     NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(PZ1,                  SDMMC1,     UP,     NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(PZ2,                  DEFAULT,    UP,     NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(PZ3,                  DEFAULT,    NORMAL, NORMAL,   OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(PZ4,                  RSVD1,      DOWN,   TRISTATE, OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(PZ5,                  SOC,        UP,     NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(DAP2_FS_PAA0,         I2S2,       NORMAL, NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(DAP2_SCLK_PAA1,       I2S2,       NORMAL, NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(DAP2_DIN_PAA2,        I2S2,       NORMAL, NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(DAP2_DOUT_PAA3,       I2S2,       NORMAL, NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(AUD_MCLK_PBB0,        DEFAULT,    UP,     NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(DVFS_PWM_PBB1,        CLDVFS,     NORMAL, TRISTATE, OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(DVFS_CLK_PBB2,        RSVD0,      DOWN,   TRISTATE, OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(GPIO_X1_AUD_PBB3,     RSVD0,      DOWN,   TRISTATE, OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(GPIO_X3_AUD_PBB4,     RSVD0,      DOWN,   TRISTATE, OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(HDMI_CEC_PCC0,        CEC,        NORMAL, NORMAL,   INPUT,   DISABLE, HIGH),
+	PINCFG(HDMI_INT_DP_HPD_PCC1, DP,         NORMAL, NORMAL,   INPUT,   DISABLE, NORMAL),
+	PINCFG(SPDIF_OUT_PCC2,       RSVD1,      DOWN,   TRISTATE, OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(SPDIF_IN_PCC3,        RSVD1,      DOWN,   TRISTATE, OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(USB_VBUS_EN0_PCC4,    DEFAULT,    UP,     NORMAL,   INPUT,   DISABLE, NORMAL),
+	PINCFG(USB_VBUS_EN1_PCC5,    RSVD1,      DOWN,   TRISTATE, OUTPUT,  DISABLE, NORMAL),
+	PINCFG(DP_HPD0_PCC6,         DP,         NORMAL, NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(PCC7,                 RSVD0,      DOWN,   TRISTATE, OUTPUT,  DISABLE, NORMAL),
+	PINCFG(SPI2_CS1_PDD0,        DEFAULT,    DOWN,   NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(QSPI_SCK_PEE0,        QSPI,       NORMAL, NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(QSPI_CS_N_PEE1,       QSPI,       NORMAL, NORMAL,   OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(QSPI_IO0_PEE2,        QSPI,       NORMAL, NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(QSPI_IO1_PEE3,        QSPI,       NORMAL, NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(QSPI_IO2_PEE4,        QSPI,       NORMAL, NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(QSPI_IO3_PEE5,        QSPI,       NORMAL, NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(CORE_PWR_REQ,         CORE,       NORMAL, NORMAL,   OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(CPU_PWR_REQ,          RSVD1,      DOWN,   TRISTATE, OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(PWR_INT_N,            PMI,        UP,     NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(CLK_32K_IN,           CLK,        NORMAL, NORMAL,   INPUT,   DISABLE, DEFAULT),
+	PINCFG(JTAG_RTCK,            JTAG,       NORMAL, NORMAL,   OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(CLK_REQ,              RSVD1,      DOWN,   TRISTATE, OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(SHUTDOWN,             SHUTDOWN,   NORMAL, NORMAL,   OUTPUT,  DISABLE, DEFAULT),
+};
+
+#define DRVCFG(_drvgrp, _slwf, _slwr, _drvup, _drvdn, _lpmd, _schmt, _hsm) \
+	{						\
+		.drvgrp = PMUX_DRVGRP_##_drvgrp,	\
+		.slwf   = _slwf,			\
+		.slwr   = _slwr,			\
+		.drvup  = _drvup,			\
+		.drvdn  = _drvdn,			\
+		.lpmd   = PMUX_LPMD_##_lpmd,		\
+		.schmt  = PMUX_SCHMT_##_schmt,		\
+		.hsm    = PMUX_HSM_##_hsm,		\
+	}
+
+static const struct pmux_drvgrp_config p3450_0000_drvgrps[] = {
+};
+
+#endif /* PINMUX_CONFIG_P3450_0000_H */
diff --git a/configs/p3450-0000_defconfig b/configs/p3450-0000_defconfig
new file mode 100644
index 000000000000..32c2b65a2979
--- /dev/null
+++ b/configs/p3450-0000_defconfig
@@ -0,0 +1,54 @@
+CONFIG_ARM=y
+CONFIG_TEGRA=y
+CONFIG_SYS_TEXT_BASE=0x80110000
+CONFIG_POSITION_INDEPENDENT=y
+CONFIG_TEGRA210=y
+CONFIG_TARGET_P3450_0000=y
+CONFIG_NR_DRAM_BANKS=2
+CONFIG_OF_SYSTEM_SETUP=y
+CONFIG_OF_BOARD_SETUP=y
+CONFIG_CONSOLE_MUX=y
+CONFIG_SYS_STDIO_DEREGISTER=y
+CONFIG_SYS_PROMPT="Tegra210 (P3450-0000) # "
+# CONFIG_CMD_IMI is not set
+CONFIG_CMD_DFU=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_PCI=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_SPI=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+# CONFIG_CMD_SETEXPR is not set
+# CONFIG_CMD_NFS is not set
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_OF_LIVE=y
+CONFIG_DEFAULT_DEVICE_TREE="tegra210-p3450-0000"
+CONFIG_DFU_MMC=y
+CONFIG_DFU_RAM=y
+CONFIG_DFU_SF=y
+CONFIG_SYS_I2C_TEGRA=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_WINBOND=y
+CONFIG_RTL8169=y
+CONFIG_PCI=y
+CONFIG_DM_PCI=y
+CONFIG_DM_PCI_COMPAT=y
+CONFIG_PCI_TEGRA=y
+CONFIG_SYS_NS16550=y
+CONFIG_TEGRA114_SPI=y
+CONFIG_USB=y
+CONFIG_DM_USB=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_TEGRA=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_MANUFACTURER="NVIDIA"
+CONFIG_USB_GADGET_VENDOR_NUM=0x0955
+CONFIG_USB_GADGET_PRODUCT_NUM=0x701a
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_USB_HOST_ETHER=y
+CONFIG_USB_ETHER_ASIX=y
+# CONFIG_ENV_IS_IN_MMC is not set
diff --git a/include/configs/p3450-0000.h b/include/configs/p3450-0000.h
new file mode 100644
index 000000000000..37c71421acbb
--- /dev/null
+++ b/include/configs/p3450-0000.h
@@ -0,0 +1,44 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * (C) Copyright 2018-2019 NVIDIA Corporation. All rights reserved.
+ */
+
+#ifndef _P3450_0000_H
+#define _P3450_0000_H
+
+#include <linux/sizes.h>
+
+#include "tegra210-common.h"
+
+/* High-level configuration options */
+#define CONFIG_TEGRA_BOARD_STRING	"NVIDIA P3450-0000"
+
+/* Board-specific serial config */
+#define CONFIG_TEGRA_ENABLE_UARTA
+
+/* Only MMC1/PXE/DHCP for now, add USB back in later when supported */
+#define BOOT_TARGET_DEVICES(func) \
+	func(MMC, mmc, 0) \
+	func(PXE, pxe, na) \
+	func(DHCP, dhcp, na)
+
+/* SPI */
+#define CONFIG_SF_DEFAULT_MODE		SPI_MODE_0
+#define CONFIG_SF_DEFAULT_SPEED		24000000
+#define CONFIG_SPI_FLASH_SIZE		(4 << 20)
+
+#define CONFIG_PREBOOT
+
+#define BOARD_EXTRA_ENV_SETTINGS \
+	"preboot=if test -e mmc 1:1 /u-boot-preboot.scr; then " \
+		"load mmc 1:1 ${scriptaddr} /u-boot-preboot.scr; " \
+		"source ${scriptaddr}; " \
+	"fi\0"
+
+#include "tegra-common-usb-gadget.h"
+#include "tegra-common-post.h"
+
+/* Crystal is 38.4MHz. clk_m runs at half that rate */
+#define COUNTER_FREQUENCY	19200000
+
+#endif /* _P3450_0000_H */
